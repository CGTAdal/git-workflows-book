
h1. Release management with git

Release management is all about branch management, and branching in git is easy. Here's the general workflow I recommend for managing releases

 * Core committers commit bug fixes and features to master branch with commit messages "Ticket #123 - short description of bug". Long running features are developed on separate branches and @merge --squash@ into master.
 * Outside contributors commit to forks, and have their changes merged in by core committers.
 * A release is cut by creating a new branch from master, or by branching from the last release branch and cherry-picking selected changesets. The master branch is tagged at the release point.
 * Emergency fixes to production are cherry-picked into the release branch.

h3. Creating the release branch

Let's say this is the first time you're creating a release. You've worked with your team to stabilize the code in _master_, and are now creating release _1.0_.

<pre>
  grb create 1.0
  git push

  git tag tag-1.0
  git push --tags
</pre>

Congratulations, you now have a 1.0 branch created, and a tag called _tag-1.0_ and ready for release. Note that at this moment, the tag and the branch are identical. The difference is that the branch pointer may continue to evolve as it gains new commits for prod fixes, while the tag is there permanently for future reference to the branch point.

h3. Using cherry-pick to move bugs into a release

Your release is running in production, and you've found a bug. Let's commit the bugfix into _master_, and then cherry-pick the same patch into the branch.

<pre>
  git co master
  # hack, hack, hack
  git commit -a -m "Bug #123 - emergency prod fix"
  git co 1.0
  git cherry-pick -x master # or using my alias 'git cp master'
  git push
</pre>

Let's take a look at what just happened. We committed the fix into master, and then we used a git command called @cherry-pick@. This command copies a patch from one branch to another. 

The @-x@ switch asks git to put the original commit id into the commit message of the cherry-picked fix so that we can easier track where it came from. Note that @cherry-pick@ takes an argument of a particular commit hash. Since we know that branches in git are simply aliases for commit hashes, we can just say _master_ to refer to the last commit in the master branch.

Note also, that since @push@ will push out all changes on matching branches to their remotes, both _master_ and _1.0_ will be updated on the remote. Fast and easy!

h3. Generating release changelogs

The gitalias file provided in the appendix offers a very handy changelog alias which generates a bulleted list of changes. Since you've tagged your last branch point, we can easily generate a list of changes from that branch point to the current HEAD of master:

@git changelog tag-1.0..master@

If you did not tag, you can find the original point at which the branch diverged, but I have found this is sometimes error prone. The @merge-base@ command will give you the last commit which is shared by two branches:

@git merge-base 1.0 master@

You can then use that commit to generate your changelog

@git changelog [commit obtained from merge-base]..master@