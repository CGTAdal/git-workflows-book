
h1. Time Traveling for Fun and Profit

With git, you've got the entire codebase history in your hands. Did you ever want to go back to yesterday's state, or last week before you broke a particular feature? Git makes it not only easy, but very fast. Let's look at a couple usecases.

h3. Searching for a specific change

If you're looking for a changeset and you remember you messed with an object called "foo_bar_baz" but don't remember quite when, you can search for it using the log. The @-p@ parameter tells git to print the actual contents of the patch so you can see the changes.

@git log -p -S"foo_bar_baz"@

If you know you made the change last week and want to save some time in the search, git understands english timeframes:

@git log -p -S"foo_bar_baz" --since="1 week ago"@

If, on the other hand, you want to search for a commit message (really handy if you put issue tracking numbers into your commit messages, something I highly recommend):

@git log -p --grep="Ticket #382"@

h3. Throwing away all changes

If you've made a mistake and want to go back to your last checkout, ignoring anything that's in the working tree or index.

@git checkout -f@

h3. Restoring a file or directory to a past state

The most basic type of time traveling is grabbing a set of changes from your HEAD. Let's say you made some changes to a file (in this case, a README) that just aren't working. Let's throw those away.

@git checkout README@

But what you're really doing here, is checking out the file from your HEAD (equivalent to @git checkout HEAD README@). You can also check out the state of the file from any given commit:

@git checkout c5d563fae README@

Now we've gone and grabbed the file from that particular commit set. Since branches and tags are just labels for particular commit hashes, we can also do the same thing use branch names.

@git checkout experimental_branch README@

But what if you know the file was working last week, now it's broken, and you want to take a look at what it was like? Easy:

<pre>git checkout "@{1 week ago}" README</pre>

When you grab a file from a previous time, it sits in your index, modified. So we can take a look at it:

<pre>
  git status
  
  # On branch master
  # Changes to be committed:
  #   (use "git reset HEAD <file>..." to unstage)
  #
  #	modified:   README
  #
</pre>

And we can see what differences it has with the current version:

@git diff --cached@

We use --cached because the file is in the index.

h3. Throwing away commits

If you've done something unsavory in your repository and want to really reset your state, you can use @git reset --hard@ which is actually equivalent to @git checkout -f@. Used without parameters, it resets your working tree and index to HEAD, which effectively gets rid of any changes.

Let's say you committed or pulled in 3 commits and now you realized you no longer want them:

@reset --hard HEAD~3@

This command tells us to revert the repository state to that of 3 commits ago. *Note:* this will effectively throw away your last 3 commits and reset your current branch's HEAD to point to HEAD~3, 3 commits ago.

h3. Reverting a changeset

As we learned in Chapter 2, while working with our local repo we have a number of tools including merging, squashing, and interactive rebasing which can help us organize our changes. Once you've pushed changes to a remote repository, it is considered dangerous to modify the history because someone else may have already pulled it. 

However, git offers you an easy way to undo a patch by committing a change that effectively reverses the patch in question. The simplest usage is to revert an entire changeset:

@git revert 850150f@

This creates a patch that is the opposite of changeset 850150f and commits it to your repo.

h3. Reverting changes to one file only

This slightly more advanced workflow using @revert@ lets you undo the changes to one file only. We'll do this by asking git to create the reverting changeset but not commit it, and modify it before it goes in. First, we'll figure out which changeset it changed in:

@git log filename@

Revert that changeset without committing it. This will put the reversion into your index.

@git revert -n [hash]@

Since we only want to revert the one file, we'll unstage all the changes.

@git unstage@ 

And now we'll stage just the file we're interested in.

@git add filename; get ci -m "Reverting change to file"@

Now we'll just throw away the rest of the changes, which we don't care about:

@git checkout -f@