h1. Who should read this book?

Git has seen a recent surge in popularity brought about largely by the popularization and, dare I say, humanization of its functionality by GitHub. Many newer projects have embraced git as a way to increase productivity, participation, and ease of collaboration. The original Peepcode Git book and gitcasts.com have done a great job by providing a great feature overview of git.

Git is an extremely powerful source control system. It's power lies in its flexibility, but this can also be a point of confusion. Git is unfortunately quite inconsistent in its syntax. Some commands do drastically different things based on options passed to them, and some equivalent operations can be performed in a variety of different ways. 

When you start to understand why certain commands behave a certain way, you begin to see that git's usage model is very close to its implementation model. By this, I mean that the git user command interface was designed around its functionality and implementation, rather than starting from the user perspective of getting a particular task done.

This book aims to show you what you can really do with git by walking through some interesting use cases and workflows. Rather than going from the bottom up and explaining git's features, we'll assume a basic familiarity and show you how you can put git to work. This book is both for those who have embraced git and are looking to take the next step, as well as those who are trying to find justifications for switching to git. 

todo. rewrite intro


h1. Getting Set Up

An excellent environment is the first step to enjoying a new tool. Below are several modifications I recommend to a default git setup in order to increase its usability. This chapter explains each modification and alias, but if you'd rather just grab the entire file, it's available in Appendix A.

h3. Show the git branch in your bash prompt

Simply place it in your .bashrc and enjoy. Here I've supplied the prompt line (PS1) from my own terminal, but feel free to modify yours as you see fit, inserting the call to $(parse_git_branch) wherever you want the branch to appear.

code.  test

function parse_git_branch {
 git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1) /'
}
# export PS1='\u@\H:\w $(parse_git_branch)$ '

export PS1='\[\033[01;34m\]\u@\h:\[\033[01;32m\]\w \[\033[00;34m\]\[\033[01;32m\]\[\033[00m\]\[\033[01;33m\]$(parse_git_branch)$ \[\033[00;37m\]'

todo. citation needed

Now, let's make a couple modifications to our ~/.gitconfig to enhance the git experience.

h3. Get colorized

It's important to make working with git easy on the eyes. Turn on colors to see diffs, status, branches, etc in color. 

code.  [color]
      diff = auto
      status = auto
      branch = auto
      interactive = auto
      ui = auto

h3. Clean things up

Git needs periodic maintenance to make it run fast. Here's a way to avoid ever having to think about it. 

code.  [gc]
      auto=1

h3. Better merge messages

By default, when you merge in git, you get a fairly meaningless message like _merge branch 'master' of git@github.com:name/project_. To get a summary of the changes you're merging, turn this option on:

code.   [merge]
        summary=true


h3. Better information on branches and remotes

By default, the _git branch_ and _git remote_ commands give you lists of things, but no information about them. Here are a couple aliases that do a little better:

code.   [alias]

h1. Chapter 1: Working Well with Others

Git is perfect for working with distributed teams. 

todo. more intro here

h2. Setting up a forked network of repos

The following examples will assume a repository hosted on GitHub. While this is not required to work with git, GitHub provides an excellent fork network visualization tool that is worth the price of admission. 

h3. GitHub fork network tracking

h4. Create your repository

shell. git init
    foo

h4. Two

h4. Three


h3. Taking a look at what other people are doing

Let's say you and Alice are working on forks of the same project on github. You are remote collaborators, and she wants your help on something she's working on. Here's how you can take a look at her work easily without dirtying up your workspace. 

We'll first set up a remote to track her repository:

code. git remote add alice git@github.com:alice/my-project.git

Let's fetch Alice's repository to make sure we have the latest changes

code. git fetch alice

We've now got all of Alice's branches in our repository. To show them, we'll use 

code. git branch -av

The -a tells us we want to see all branches (including remotes), and the -v gives us information about the latest change on each branch.

Now, let's create a new local branch to look at Alice's master branch:

code. git checkout -b alice_master alice/master

Your working tree has now been replaced with Alice's master branch. You can take a look around using your favorite code editor, and help Alice figure out her problem. 

h3. Remote pair programming using temporary branches

Let's say your team is now using a central git repository to share changes. You, Alice, and Bob are working on remote forks of the central repo. 

h4. Create a new temporary branch

code. git checkout -b temp
code. hack hack hack
code. git push origin temp:refs/heads/temp

h3. Pulling changes into your repository

You and Alice decide that you will finish the feature she's working on. You've already fetched her repository, so you decide to merge in her changes so that you can work on them.

Switch to your master branch,

code. git co master

And merge in Alice's work

code. git merge alice/master

If you didn't previously fetch Alice's repo, or you think you might be out of date, you can use pull to automatically fetch and merge into your local branch:

code. git pull alice master

Now you've got her changes in your working tree and you can make new commits on top of them to finish up the project. 

h1. Chapter 2: Time Traveling for Fun and Profit

With git, you've got the entire codebase history in your hands. Did you ever want to go back to yesterday's state, or last week before you broke a particular feature? Git makes it not only easy, but very fast. This is why I call it time traveling. It's nearly instantaneous. Let's look at a couple usecases.

h3. Looking at differences across time, branches, commits

h3. Restoring a file or directory to a past state

The most basic type of time traveling is grabbing a set of changes from your HEAD. Let's say you made some changes to a file (in this case, a README) that just aren't working. Let's throw those away.

code. git checkout README

But what you're really doing here, is checking out the file from your HEAD. You can also specify a particular commit hash:

code. git checkout c5d563fae README

Now we've gone and grabbed the file from that particular commit set. Since branches and tags are just labels for particular commit hashes, we can also do the same thing use branch names.

code. git checkout experimental_branch README

But what if you know the file was working last week, and now it's broken? Easy:

code. git checkout "@{1 week ago}" README

Git speaks in human timeframes. Try using hours, days, etc. It works like magic!
When you grab a file from a previous time, it sits in your index, modified. So we can take a look at it:

code. git status

    # On branch master
    # Changes to be committed:
    #   (use "git reset HEAD <file>..." to unstage)
    #
    #	modified:   README
    #

And we can see what differences it has with the current version:

code. git diff --cached

We use --cached because the file is in the index. 

h1. Chapter 3: Keeping your change sets clean

todo. talk about git add --patch, git rebase -i, git commit --amend, and reset --soft HEAD^

h2. Keeping your changes separate

h2. Fixing old commits 

h2. Protecting against incorrect or dangerous rebasing

pre-rebase ...

h1. Chapter 4: Working with legacy systems using git-svn

h2. Sneaking git through the backdoor

Mixing git and svn on a team...

h2. Working with git-svn and a central git repo (github)


h1. Branching, Stashing, and Always Being Prepared

h1. Git and TextMate


h1. Appendix A: The .gitconfig

todo. wrap in code block

[color]
        diff = auto
        status = auto
        branch = auto
        interactive = auto
        ui = auto
[gc]
        auto = 1
[merge]
        summary = true
                
[alias]
        d = diff                        # show unstaged changes
        dc = diff --cached              # show staged changes
        unstage = reset HEAD            # remove files from index (tracking)
        uncommit = reset --soft HEAD^   # go back one commit, with files in uncommitted state
        chunkyadd = add --patch         # stage commits chunk by chunk
        filelog = log -u                # show changes to a file
        amend = commit --amend        

        b = branch -v
        r = remote -v

        ci = commit
        co = checkout
            
        # (mnemonic: "git new branch branchname...")
        nb = checkout -b  

        stat = status
        s = status

        # nice logs
        changes = log --pretty=format:\"%h %cr %cn %Cgreen%s%Creset\" --name-status
        short = log --pretty=format:\"%h %cr %cn %Cgreen%s%Creset\"

        # svn helpers
        svnr = svn rebase
        svnd = svn dcommit
        svnl = svn log --oneline --show-commit
