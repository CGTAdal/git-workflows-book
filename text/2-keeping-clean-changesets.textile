
h1. Keeping your changesets clean

Git provides a number of tools which can alter your commit history to clean up your changes after the fact, as well as tools to use prior to and during commit time to keep separate changes separate. I use this capability to maintain a _one changeset per feature, one feature per changeset_ development philosophy. 

This is important for two reasons: First, because it makes it easy for your fellow developers to see change history in one spot and do simple code reviews without tracking a bug or feature across many commit sets. Second, because it simplifies constructing selective releases on the fly (picking a specific set of bugs and features to be included into a new branch). 

h3. Using the index for breaking apart quick changes

Before we get to topic branches and keeping different workspace for your bugs and features, let's take a look at a quick way to create separate commits from a single set of changes. 

h3. Making several commits from one set of changes

Let's say you've been hacking away for a couple hours and now you've got two different sets of changes in your working tree. We run @git status@ to see what's available.

<pre>
# On branch master
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#	modified:   public/file1
#	modified:   public/file3
#	modified:   file2
#
</pre>

Unlike many of git's obscure error messages, the status screen is actually very friendly and explains what to do. On the status screen above we see we have modified two files and added a new file. But it turns out that 'file1' and 'file3' are part of a bugfix, and 'file2' is an unrelated change. Using the color settings outlined in Chapter 1, you'll see the files shown in red, indicating that they are not yet staged for commit.

We stage a change for commit by adding it to the index. Because git operates on changes, and not on files, it's easy to add all changes in a particular directory:

@git add public@

This adds the changes made to file1 and file2 to the index (interchangeably referred to as the staging area). I could also do it by listing the files after the add command, or by issuing multiple add commands. If I wanted to add all available changes I could simply use @git add .@ After running the command, the status shows:

<pre>
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   public/file1
#	modified:   public/file3
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#	modified:   file2
</pre>

You'll notice that the files that are added to the index, under "Changes to be committed" are now colored green instead of the previous red. Now to commit the two changes that have been staged, we issue the commit command:

@git commit -m "This is my commit msg"@

Now we're left with the change to file2 in our working tree, and we can follow the same procedure to commit the one file. 

<b>Note:</b> Some beginning git tutorials encourage you to use the syntax @git commit -a -m@ to bypass the index and commit all changes. I recommend _never doing this_ because it is very easy to mass commit unrelated changes. Always use _git status_ to find out what's been changed, and selectively add files to the index before committing.

h3. Using @git add@ for deleted files

One slightly annoying thing about @git add@ is that it does not take into account deleted files. Typically, git would like you to use @git rm@ to delete files, but in practice, using command line or IDE you are likely to delete files using traditional methods.

To add deletions to the index, a handy shortcut is @git add -u@, which tells git to add all files it knows about, including deletions. When wanting to add all changes, I typically use a combo of @git add .; git add -u@

h3. Staging unrelated changes within one file

Git can also help you tease apart unrelated changes within one file, and add them selectively to the index. I find that I use this rarely because I try to work on separate changes in separate branches, but if you do find yourself in this scenario, git makes it easy:

@git add --patch@

This will launch an interactive prompt which will go through each change in each unstaged file and ask you whether you want to stage the hunk in question. Simply answer the questions, and when you're finished you will see that the file is both in the staged and unstaged areas of the status output. To see which changes are staged, we use

@git diff --cached@

The @--cached@ argument means we're working with the index. Strangely this is probably the only place in git that refers to the index as a cache. Effectively this command says "give me the difference between the cache (index/staging area) and the HEAD (last commit)". You can also do a diff for the unstaged changes:

@git diff@

Note that this diff does __not__ include the staged changes. This is a handy way to see the differences in both areas. Use this a couple times alongside @git status@ and you should get a grasp on the technique pretty quick. I use the aliases @d@ for @diff@, and @dc@ for @diff --cached@, so that it's easy on the fingers.

Of course, diff takes more arguments, so that you can compare to something other than HEAD (like another branch, say) and is quite flexible. For more info, see the EXAMPLES section of the @git diff@ manpage.

h3. Using topic branches

Though the methods described above are good for quick hacks, when working on larger bugs or features, you can start to use branches to separate your work into workspaces and work on multiple thing without them interfering with each other.

h3. One branch per bug

Whenever you start to work on a feature or a bug, create a new branch locally. This branch will live for the duration of the work you do, and then we'll squash it into one clean changeset back into the master, following our _one commit per feature_ philosophy.

@git checkout -b bug123 master@, 

Work on bug fix 123, making commits as you go. Realize that you actually need to start work on feature456 now.

@git checkout -b feature456 master@

Work on feature456, make commits. Now go back to the bug.

@git checkout bug123@

Make some more changes. Now we're done, so let's bring these changes back to the master.

<pre>
git checkout master
git merge --squash bug123
git commit
</pre>

Don't you love squashing bugs? The @--squash@ parameter brings in all the commits from the _bug123_ branch as if they were one change. It also avoids logging the change as a merge, so it looks like you just made one clean commit with all the changes from the bug123 branch as one. Once you're sure you don't need the history of working on that bug anymore, delete the branch.

@git branch -D bug123@

I like to use the alias @nb@ for new branch, so that the commands above become:

@git nb feature123 master@

Also note that if you're creating a branch from the branch you're currently on, then the second argument can be ommitted, so if you're on the master branch already, simply use:

@git nb feature123@

h3. Coming back to unfinished work on a topic branch

Let's say it's Friday afternoon and you're halfway through a refactoring but you want to save it until next week. A good way to remember that it's unfinished work is to log it in the comments.  Simply commit your changes with a helpful message:

@git commit -a -m "uncommit me: need to finish stuff in the user model"@

Note that above we used the @-a@ switch which tells git to automatically stage all your changes. It's as if you ran @git add .@ right before the commit. When you come in on monday, you can see your list of available branches:

<pre>
git branch -v
* bug123      937c391 uncommit me: need to finish stuff in the user model
</pre>

And remembering that you were working on bug123, you check out the branch to resume work:

@git checkout bug123@

@git uncommit@

The @uncommit@ alias is covered in Appendix A, and is the aliased to @git reset --soft HEAD^@. Effectively, it takes you back in time to the moment right before you made the commit, with all of your changes still in the index. This means you can now examine your changes and modify them if necessary and commit again.

h3. Fixing the last commit

The uncommit command above shows you how to resume work on a previously committed changeset. If you're simply adding a couple files or changing the commit comment on your last changeset, a quicker way to do this is

@git commit --amend@, or using the alias @git amend@

As usual, you'll have to @add@ your changes to the index before you do this. The amend command will not create a new commit, instead it will modify the last commit. *WARNING:* never do this to a commit that you've already pushed to a remote repository.

h3. Using the stash to temporarily hide your changes

Using uncommit is my favorite way of resuming long running work, but if you're working on something and a production bug comes in that takes priority, you can quickly toss your changes into a place git calls the _stash_. You can think of it as a temporary branch that works like a stack. Every time you type @git stash@, your changes are removed from your working tree, restoring your files to the last checked out state, and the changes are saved as a changeset on the stash.

You can then pop your changes off the stash by using @git stash pop@ or @git stash apply@ to apply the change without popping it off the stash. Use @git stash list@ to see the contents of the stash.

<pre>
  # do some work, prod bug comes in
  git stash
  git checkout prod_branch
  # fix your prod bug and commit
  git checkout master
  git stash pop
</pre>

Another good use of the stash is for moving uncommitted between branches. Sometimes you start to work on something on master, or on another branch and realize the work probably needs to be moved over to a branch of its own. While you can sometimes checkout another branch and the changes will automaticaly transfer over, occasionally your changes conflict with the code on the branch, so the correct way to do this is to _stash_ the changes, checkout the new branch, and then unstash them. 

h3. Keeping a topic branch in sync with its parent

When you've wandered off for a while on your topic branch, working on your bug or feature, you'll occasionally want to grab updates that have been made in the master branch, or wherever you branched from. The best way to do this is to use the @rebase@ command. The functionality of rebase is best illustrated with a diagram from the git manpages:

<pre>
Assume the following history exists and the current branch is "topic":

          A---B---C topic
         /
    D---E---F---G master

From this point, the result of either of the following commands:

git-rebase master
git-rebase master topic
would be:

                  A'--B'--C' topic
                 /
    D---E---F---G master
</pre>

So what rebase does is stash your changes, grab the latest from master, and then apply your changes on top. This effectively makes it as if rather than branching several days ago, you just branched now from te tip of the master and made your commits there.

Most of the time, this will work without a hitch. However, you may occasionally get a merge conflict if the same file has been modified in the same place on both branches. If this happens, git will complain with a very loud and verbose error message. The important thing with git is always to read the end of the message. You will then see that it tells you to resolve the conflict and then @git rebase --continue@ or @git rebase --abort@. 

h3. Changing commit history to clean up change sets

*WARNING:* you should never alter commit history after you have pushed your changes to a remote repository.

If you've been following the above techniques and keeping your work in separate branches, squashing full changesets into master, you'll hopefully never have to do interactive rebasing. However, one scenario where this technique is useful is when you've pulled a large set of changes from another repo (more on working with others in Chapter 4). 

Your friend may not have been following the clean changeset philosophy as you have, so you'd like to fix the commits you just pulled from him by fixing some commit messages, maybe edit some of the code in one of the commits, and perhaps combinging some of his commits into larger changesets.

The @rebase -i@ command is a powerful way to gain editorial capabilities over your last N commits. To launch it, use the following syntax:

@git rebase -i HEAD~[N]@

Substituting @[N]@ for the last N commits that you want to work with. 

Once you have done this, you'll be presented with an editor screen with instructions. It will look something like this:

<pre>
  pick 06e0e1a (dev) Add query stats at top of page for dev/devcache
  pick 850150f (dev) Disable newrelic in test01 and dev01
  pick 737b01b Ticket #1606 - error while accessing /db_admin/available_distro

  # Rebase 5926a38..737b01b onto 5926a38
  #
  # Commands:
  #  pick = use commit
  #  edit = use commit, but stop for amending
  #  squash = use commit, but meld into previous commit
  #
  # If you remove a line here THAT COMMIT WILL BE LOST.
</pre>

The screen offers a clean set of instructions to follow. Simply edit the file and change the word 'pick' to 'edit' if you want to change the commit in any way. Once you've decided which commits you'll be working with, git will exit the screen and begin taking you through every commit. At every stage, make sure you read the directions which are pretty simple. You will have the opportunity to edit any commit you want, and commit it again. Once you have done so, @git rebase --continue@ will take you to the next commit on your list until you're done.

You can learn more about interactive rebasing here: <a href="http://book.git-scm.com/4_interactive_rebasing.html">http://book.git-scm.com/4_interactive_rebasing.html</a>