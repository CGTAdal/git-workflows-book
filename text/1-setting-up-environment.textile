
h1. How git works: building a mental model

If you're familiar with subversion, you're used to one central repository, which everyone interacts with by pulling and pushing changes. While you can use git in this way (something we'll talk about in Chapter 3), there are many fundamental differences to understand. 

With git you always have the entire repository in your hands, including all its history, branches, and tags. A git project starts in one of two ways. Either you create the repo locally using <code>git init</code>, or you start working on someone else's existing project by using <code>git clone [repo url]</code>. 

Let's examine the three basic components of a git project tree:

h3. The Repository

The basic unit that git works with is the _changeset_ (also called a _patch_). Almost all git commands have to do with operations on changesets, not on files. Keep this in mind if coming from a subversion background. Every git changeset is identified by a SHA-1 hash which looks like this: c15724ef2b99852564a92f9d90c93f9cb6e037ff. The hash is a unique reference to a particular set of changes on a particular branch, and is unique across your repository. Most of the time the first five or so characters of the hash are unique enough to identify it. So you'll sometimes people abbreviate changeset id's by giving you just the short hash.

Unlike subversion, which litters every directory in your tree with its metadata files, the entire git repo lives in one directory called @.git@ at the top level of your project. Without going into too much detail, this directory contains a list of _objects_ which are binary representations of your changesets, and a list of _refs_ which are the human names you use to refer to your branches and tags. I recommend poking around the @.git@ directory to see what's inside. Most of it is human readable and very educational.

If you've just started or cloned a git project, you'll find you typically have a branch called _master_. There is nothing special about this branch other than it's the conventional way to name the main development branch -- the rough equivalent of _trunk_ in subversion. Git branches are nothing more than human names for a particular changeset. To verify this, just take a look at the file .git/refs/heads/master. Inside, you'll see the hash that identifies the latest commit in your repository on the master branch.

h3. The Working Tree

The working tree is the set of files you're currently working with. To start working on something in your git project, you first @checkout@ a particular branch from your repository. When you checkout code, you specify the name of a branch you'd like to work with, and the files in your working tree are replaced with the files from the branch. The files in your working tree are literally overwritten by your checkout - but not to worry. Git will not let you do something stupid like overwrite your changes with a checkout. If your working tree is dirty, git will warn you that checking out a particular branch will overwrite your changes and prevent you from doing so. We'll talk about how to deal with this later.

h3. The Index

There is a place interchangeably known as the index, cache, or staging area. This is where you put your changes before they are ready to be comitted to the repository. You'll learn more about the index in Chapter 2, but for now just think of the index as a place that lets you selectively commit changes you make. For example, if you've made a set of file modifications, but it turns out they are two unrelated changes, you can add the appropriate half first to the index, make the commit, and then add the second half and make another commit.

A great image of the git workflow and all the parts of the repo is http://osteele.com/images/2008/git-transport.png

For more introduction to how git works, please see PeepCode's Git Internals book.

h1. Setting up your environment

An excellent environment is the first step to enjoying a new tool. Below are several modifications I recommend to a default git setup in order to increase its usability. This chapter explains each modification and alias, but if you'd rather just grab the entire file, it's available in Appendix A.

h3. Git bash completion

So that you don't have to type out branch names and other things, locate the file _git-completion.bash_ and add it to your startup scripts so that it executes. This typically involves adding a line to ~/.bashrc:

@. /path/to/git-completion.bash@

If you can't locate the file, try http://repo.or.cz/w/git.git?a=blob_plain;f=contrib/completion/git-completion.bash

h3. Show the git branch in your bash prompt

It's very helpful to know which branch you're on at any given time to prevent mistakes. Simply place the following code in your .bashrc and enjoy. Here I've supplied the prompt line (PS1) from my own terminal, but feel free to modify yours as you see fit, inserting the call to $(parse_git_branch) wherever you want the branch to appear.

The code below also provides for a 'gitpushable' alias which tells you about outgoing changes in your current branch, that have been committed but not pushed to your remote origin (more on this later - but the origin is the defacto name for the standard remote branch, your central repo if you will).
 
<pre>
  function current_git_branch {
   git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
  }

  function parse_git_branch {
    if [ -n "`current_git_branch`" ]; then
      echo "(`current_git_branch`)"
    fi  
  }

  alias gitpushable='git log origin/`current_git_branch`..`current_git_branch`'

export PS1='\[\033[01;34m\]\u@\h:\[\033[01;32m\]\w \[\033[00;34m\]\[\033[01;32m\]\[\033[00m\]\[\033[01;33m\]$(parse_git_branch)$ \[\033[00;37m\]'
</pre>

(via <a href="http://asemanfar.com/Current-Git-Branch-in-Bash-Prompt"/>http://asemanfar.com/Current-Git-Branch-in-Bash-Prompt</a>)

Now, let's make a couple modifications to our ~/.gitconfig to enhance the git experience.

h3. Get colorized

It's important to make working with git easy on the eyes. Turn on colors to see diffs, status, branches, etc in color. 

<pre>
[color]
  diff = auto
  status = auto
  branch = auto
  interactive = auto
  ui = auto
</pre>

h3. Automatic cleanup and compression of the repo

Git needs periodic maintenance to make it run fast. Here's a way to avoid ever having to think about it by making it run automatically. 

<pre>
[gc]
  auto=1
</pre>

h3. Better merge messages

By default, when you merge a branch in git, you get a fairly meaningless message like _merge branch 'master' of git@github.com:name/project_. To get a summary of the changes you're merging, turn this option on:

<pre>
[merge]
  summary=true
</pre>

It's also handy when doing @cherry-pick@ to copy changes from one branch to another, to have git automatically put the original commit hash into the commit comment. Here's an alias for doing this:

<pre>
[alias]
  cp = cherry-pick -x
</pre>

h3. Better information on branches and remotes

By default, the git @branch@, @remote@, and @tag@ commands give you lists of things, but no information about them. Here are some aliases that do a little better. 

<pre>
[alias]
  b = branch -v
  r = remote -v
  t = tag -l
</pre>

h3. Two useful aliases: unstage and uncommit

There are many other aliases given in the .gitconfig included in the Appendix, but these two are aliases for otherwise hard to remember commands.

<pre>
[alias]
  unstage = reset HEAD
  uncommit = reset --soft HEAD^
</pre>

This is a case of git doing completely different things depending on switches given to the reset command. This powerful command can be used to throw away commits, or time travel to previous states. While it will be discussed more in Chapter 2, let's look at these aliases.

<code>unstage</code> is the opposite of <code>git add</code>. It lets you remove items from the staging area. This makes it a very useful tool when you're deciding which files to stage for a commit. If you've accidentally added something to the staging area, just use <code>unstage</code> to remove it. 

<code>uncommit</code> is a technique I often use. It removes the last commit from your repository, and puts the changes into your index. It's like going back in time to the moment right before you committed. This is a useful technique in resuming work on an unfinished changeset. But please don't do it if you've already pushed this changeset to a place where someone may have pulled it from, because you'll be changing the commit history in a nonlinear way. 

These aliases and their usage are discussed in detail in Chapter 2.

For more aliases, please see the appendix which includes the entire recommended .gitconfig.