
h1. Remote collaboration and code review

Git is great for remote collaboration because of several factors:
 
* As long as people have read access to your repo, they don't need your permission to clone it and do their own work on their fork. Having their own fork also means they can maintain their own branches without polluting the main repository with personal experimental branches.
* It is easy to pull in work from team mates, and because of cheap branching it's easy to experiment before committing results to the main repository. Because branching is easy, git encourages code review by using branches before the code goes into the master branch.
* GitHub provides an excellent service that helps you track who has cloned your repository and what work they've done. It also offers fantastic per-line code review capabilities.
  
Here we'll take a look at a couple common ways of sharing work using git. This chapter will assume you have an account on GitHub, and that you're using GitHub as your central repository, through which everyone collaborates.

h3. Using git remotes for collaboration

While it's possible to use git completely by yourself, without a remote repo, it's much more useful in a collaborative environment. While there are myriad ways you can use git remotes, I am going to advocate a specific approach that I have found works well:

 * All code is hosted on and shared through GitHub. There will be no peer to peer sharing (grabbing code directly from someone else's repository hosted via git-daemon or similar).
 * Only some team members have direct commit access to your project (we'll call them the _core committers_).
 * Some team members are junior developers or outsourcers whose work is reviewed by and merged in by the core committers (we'll call them _contributors_).
 
This chapter will illustrate how to collaborate on code creation with this sort of team. If your organization uses either a pure core committer model, or pure contributor model, you can still pick and choose the parts of the workflow that make sense to you. 

h3. Set up your remote at GitHub

The first thing you'll do is setup your repository on GitHub (http://github.com). If you are working for a company, I recommend setting up the account in the company's name so that contributors know that it's the official repo for the project. Each developer should have his own personal GitHub account (using the free account is fine), which he will use to either contribute directly, or fork the main repo.

Create a new project, and follow GitHub's instructions for pushing your changes out to your newly created repo. If you already have a git repo, the steps typically look like this:

First, add a __remote__ (git's term for a remote repo) called __origin__ (this is simply a convention for the primary repo that you push to and pull from). 

<pre>git remote add origin git@github.com:[username]/[repo-name].git</pre>

You can always see all the remotes you have:

@git remote -v@

Once you have the remote, you'll push the code you have out:

@git push origin master@

This command tells git to push all the changes you've made on your _master_ branch, to the _master_ branch on the remote called _origin_. It's actually a shortcut syntax. Because your local and remote branches are both named __master__, you don't have to specify the remote branch name. If you wanted to call your local branch __foobar__ instead, you could use the syntax

@git push origin foobar:master@

Git offers a secondary shortcut convenience. If you name all your local branches identically to your remotes, then you can just use:

@git push@

This will push out changes on all branches that have matching branches on the remote end.

*Note:* You should take a look at the file called .git/config. This file lists all your branches and remotes, and has interesting information that will help you learn about what git does internally to track your branches and their relationship to remotes. 

h3. git-remote-branch, a handy automation for remote branches

Git is pretty low level when it comes to managing local and remote branches and keeping them in sync. Enter git-remote-branch: a great tool that helps you automate day to day operations on remote branches. As a bonus, it shows you exactly what it's doing under the hood so you can learn more about how git works. The rest of this chapter will assume you have git-remote-branch installed, and are using the @grb@ command.

Homepage: http://github.com/webmat/git_remote_branch/tree/master
Installation (you will need rubygems for this):

@sudo gem install git_remote_branch --include-dependencies@

Once you've installed the tool, go ahead and run @grb@ without arguments to see the help. 

h3. Creating and pushing to remote branches

If you're working on a long lived topic branch for a particular feature, it's a good idea to back it up to your remote. It's also useful to push it out to the remote so that others can look at it and collaborate with you. To push an existing branch to the remote:

@grb share [branchname]@

If you haven't yet created the branch, 

@grb create [branchname]@

Which both creates the local branch and pushes it to the remote. 

h3. Deleting a remote branch

When you're done with an experimental branch, you delete it locally with:

@git branch -D [branchname]@

But your branch is still active on the remote. To delete it, git has a slightly obscure syntax

@git push origin :[branchname]@

Of course, @grb@ makes it much simpler to do both in one shot

@grb delete [branchname]@

h3. Pulling changes from a remote

The opposite of push is a pull, and allows you to grab code that someone else has committed. The pull is done in two steps. The first step, @fetch@, downloads code from the remote repo into your local git repo (the directory called _.git_, NOT your working tree). 

The second step is getting the changes from the remote branch into your local working tree by using either @merge@ or @rebase@. Let's take a look at how this works.

Suppose you're working on a branch called _bug123_ at your github repository. A coworker has committed changes to the branch that you wish to pull in.

First, we fetch the latest changes from the remote repo. This will download __everything__ in the remote repo into our local repo. This includes all remote branches. Remember that with git, you're storing the entire repository locally.

@git fetch origin@

To show all the branches we now have, use:

@git branch -av@

The @-a@ tells us we want to see all branches (including remote ones, you can see _only_ remote branches by using @-r@), and the @-v@ gives us information about the latest change on each branch. Note that the branches listed as "origin/[branchname]" are called __remote tracking branches__. Think of these branches as local read-only mirrors of the remote repo.

If you ever try to check out a remote tracking branch directly:

@git checkout origin/master@

You will get a warning from git that looks like this:

<pre>
  Note: moving to "origin/master" which isn't a local branch
  If you want to create a new branch from this checkout, you may do so
  (now or later) by using -b with the checkout command again. Example:
    git checkout -b <new_branch_name>
</pre>

So in order to actually work with the remote branch, we'll need a local tracking branch set up to track the remote branch in question:

@git checkout -b bug123 origin/bug123@

@Branch bug123 set up to track remote branch refs/remotes/origin/master.@

h3. Pulling changes using merge

Once you've fetched all the remote branches and opened up the local tracking branch you want to work with, you'll merge the latest changes from the remote:

@git merge origin/bug123@

To automate the fetch and merge steps, git offers a @pull@ command that does both in one shot:

@git pull origin bug123@

*Note:* whenever you merge, a commit message will be left in your local repo indicating the merge. This is because to git, there is no such thing as a central repo. Even if you and your team are using github to collaborate, each of your individual repos is treated as an equal, and merges are logged there just as they are anywhere else. 

When working on long lived branches where multiple developers are constantly syncing up to it, I dislike merge commits because they dirty your repo history with essentially meaningless messages. To avoid this, we can use rebase instead.

h3. Long lived remote collaboration using rebase

Remember @git rebase@, discussed in Chapter 2? This command lets you move your work to the tip of a branch as if you had just started the work from the tip. This can be used to keep in sync with a remote repo as well. Let's say you've been working on your branch _bug123_ and have made 3 commits. Meanwhile your coworker has pushed 2 commits to _origin/bug123_ (at github). 

You can grab his changes, and replay your changes on top by using the same rebase technique:

@git fetch origin; git rebase origin/bug123@

There is no difference between this and the rebase usage covered in Chapter 2, other than that we're rebasing from a remote tracking branch. Git also offers a shortcut to pull in this manner:

@git pull --rebase origin bug123@

If this is the way you prefer to work, you can have git always rebase instead of merge your pulls by editing your _.git/config_ file for the branch in question:

<pre>
[branch "master"]
  remote = origin
  merge = refs/heads/master
  rebase = true
</pre>

*Note:* as before, make sure you understand what you're doing with rebase. It will rewrite your commit hashes, so if you've pushed your code out to one place and rebase from another, you'll be in trouble. However, if you use rebase as recommended here, to sync with only one GitHub repository, you will have no problems.


h3. Core committer collaboration workflow

So, now that we know how to use @git pull --rebase@, let's take a look at a typical scenario in collaboration between two core committers, Alice and Bob, who work for BugFreeCode, Inc. working on a bug together:

 1. Alice creates a branch and makes commits
 2. Bob pulls her changes and makes additions
 3. Alice pulls Bob's changes
 4. Alice squashes bug into master and closes the branch

Alice starts working:

<pre>
grb create bug123
# hack, hack, hack
git ci -a -m "Bug #123 fixed, needs code review"
git push origin bug123
</pre>

She then asks Bob to do a code review on the branch. Bob pulls in Alice's changes:

<pre>
git nb bug123 origin/bug123 # first time only
git co bug123; git pull --rebase origin bug123 # to sync it up
# hack, hack, hack
git ci -a -m "Bug #123 - Cleaned up alice's code"
git push origin bug123
</pre>

Alice, who is the owner of the bug, now decides the bug is good to go, and merges it into the _master_ branch, which their team uses as a starting place to create releases. 

<pre>
git co bug123
git pull --rebase origin bug123
git co master
git merge --squash bug123
git ci -m "Bug #123 - fixed all sorts of stuff. Thanks to Bob for the help."
git push # update the remote master branch
</pre>

Since the bug is now in master, if there is no long term need to keep its history around, Alice deletes the branch from her local repo, and the remote.

@grb delete bug123@

h3. Squashing for code review

If Alice has made ten changes while working on her new feature, we'll call _feature-x_, and she wants her team to review her work, it is easier to review it as one cohesive changeset. While the _bug123_ branch is still useful to track the history of the work on the bug as she debugs it with Bob, she only wants to show the one finalized changeset:

Using the @merge --squash@ technique discussed in Chapter 1, we can create a changeset that will combine all her changes into one. By pushing this changeset out to GitHub, you can get a nice way to do code review with GitHub's line-by-line comment feature.

I like to add _-squashed_ to the end of the branch name so that I know it's a temporary branch meant just for reviewing commits. Below, we create a branch called _bug123-squashed_, branched from _master_, and create a squashed changeset, pushing it out to GitHub.

<pre>
grb create bug123-squashed
git merge --squash origin/bug123@
git commit -m "Bug #123 - squashed commit for code review"
git push
</pre>

Now, Alice can refer her team to the GitHub url for the changeset, and collect comments using the web interface at GitHub, or coworkers can directly checkout the _bug123-squashed_ branch and use @diff@ and @show@ commands to inspect it.

h3. Outside contributor collaboration workflow

While Alice and Bob work together by directly committing to the GitHub repo, they outsource part of their project to contributor Charlie. Alice is the project leader, so she takes on the primary task of reviewing Charlie's work, and merging it into the main repository.

The workflow recommended for outside contributors is as follows, using Alice as an official core committer, and Charlie as the contributor

1. Charlie creates a branch for every feature or bug
2. Charlie has a remote repo link to the official repo 
3. Alice examines code committed by Charlie, adds her own changes
5. Alice merges Charlie's changes into the official __master__
6. Charlie pulls changes from official _master_ into his own _master_

You already have all the tools you need to execute this workflow. Let's walk through it.

h3. Setting up remote contributor forks

First, Charlie signs up for his own GitHub account. He then visits the project's homepage under the company's GitHub account, and clicks the Fork button. This button creates a clone of the repo for Charlie under his own account.

GitHub offers a nice feature for fork network tracking and visualization which is probably worth the price of admission alone. The company can now look at who has forked the project, and what kind of commits they have made. This makes it easy to know when something is worth pulling in.

Once Charlie has his fork, he follows the instructions provided by GitHub to clone the fork on his local machine, which looks something like this:

<pre>git clone git@github.com:charlie/some-project.git</pre>

Charlie now has an _origin_ which refers to his own project on GitHub. But he's going to occasionally want to sync up to the official repo owned by BugFreeCode, Inc, so he'll add a remote for the original repo, as well:

<pre>git remote add bugfree git@github.com:bugfreecode-inc/some-project.git</pre>

h3. Taking a look at contributor's work

To track Charlie's progress, Alice sets up a remote link to Charlie's repo:

@git remote add charlie git@github.com:charlie/some-project.git@

She can then directly view branches using

@git show charlie/bug123@

Or, by using the techniques from the beginning of the chapter to create local tracking branches for contributing to Charlie's work:

<pre>
  git nb bug123 charlie/bug123
  # hack, hack, hack - helping charlie out
  git ci -a -m "code review and fixing to help Charlie"
  git push charlie bug123

  # once the bug is done, put it into master
  git co master
  git merge --squash charlie 123
  git ci -m "Bug #123 - fix something" --author "Charlie <charlie@charlie.com>"
  git push
</pre>

Charlie keeps himself in sync to the official master branch by using @pull --rebase@:

<pre>
  git co master
  git pull --rebase bugfreecode master
</pre>

If Charlie does all his work on branches and never touches his master, another equivalent way, but perhaps slightly safer (avoiding any rebase troubles), is to reset to point to the master
<pre>
  git co master
  git fetch bugfreecode; git reset --hard bugfreecode/master
</pre>

h3. Cleaning up stale remote tracking branches

Once you're finished collaborating on remote branch bug123, one of the developers will delete the remote branch, but everyone else will still have that branch listed in their @git branch -a@ output. To remove any stale tracking branches that are already gone from the remote, simply use

@git remote prune origin@

Where _origin_ is the name of the remote. Do this for every remote you have periodically to maintain a clean branch list.

h3. Dealing with conflicts during merges

When you merge another branch, you may occasionally get a CONFLICT if the code in the same place has been modified in ways that git cannot easily merge. Git will provide a warning message

<pre>
  git merge --squash origin/bugfix
  CONFLICT (content): Merge conflict in app/models/foo.rb
</pre>

There are two ways to deal with conflicts. I've found the easiest thing is to simply open up the file in question, and find the conflicting section. It will look something like this:

<pre>
<<<<<<< HEAD:app/models/foo.rb
  your_line_of_code_
=======
  new_line_of_code_from_remote
>>>>>>> origin/bugfix:app/models/foo.rb
</pre>

Simply edit the file to remove the "<<<" and ">>>" markers, leaving the correct line of code in place. The other way to do this is to run @git mergetool@. This command will automatically launch whatever available merging utility you have on your system (typically FileMerge on OSX), and give you a graphical UI for picking one line or another. It's really a matter of personal preference but after some experience I found it's actually easier to understand the changes by looking at the file directly.

You'll also notice that the conflicted file didn't get added to the index, so once you've resolved all your conflicts, simply

@git add .@

To add all the changes to your index, and commit.

h3. Dealing with conflicts during rebase

TODO/UNFINISHED: rebase conflict management. git rebase --abort/--continue etc.

http://jdwyah.blogspot.com/2008/09/merging-with-git-conflicts.html


h3. Bonus: Serving up your local repo to a friend

While I strongly advocate using a centralized repo service like GitHub, sometimes you just have a local project you want to share with a friend or two. You can fire up a git repository server very quickly using the following command:

@git daemon --reuseaddr --verbose --export-all --base-path=/path/to/root/of/repos@

Your friend will then add the repo in question to his remotes

@git remote add somerepo git://your.ip.address/project-folder-name; git fetch@

Please see the @git help daemon@ for further discussion on this topic. 