h1. What this screencast covers

Welcome to the Git Workflows screencast. In this video we'll take a look at how to use the Git version control system to improve your development efficiency, maintain clean changeset history, increase collaboration, and bring git into your workplace.

This screencast assumes a basic familiarity with git, and encourages a specific workflow and development philosophy. While we won't cover all the possible usages of each git command (there are way too many), we'll give you what we feel are the best ways to make git a useful tool in your daily development workflow.

If you haven't been exposed to git, we recommend checking out the following links:

* http://whygitisbetterthanx.com/ - with great diagrams showing not only how the git repos work, but also some of the workflows and collaboration models we'll discuss in this screencast.
* <a href="http://peepcode.com/products/git-internals-pdf">Git Internals by Scott Chacon, published by Peepcode</a>

h2. A brief recap

Let's quickly recap on how git works. I'm going to skip over the technical details, which are well covered in the Git Internals book, and go into the practical usage of git:

With git you always have the entire repository in your hands, including all its history, branches, and tags. A git project starts in one of two ways. Either you create the repo locally using <code>git init</code>, or you start working on someone else's existing project by using <code>git clone [repo url]</code>. 

A git repository lives in a directory called __.git__ at the root of your project directory. You create a git repository by cloning an existing one, or by using __git init__.  This directory contains a list of _objects_ which are binary representations of your changesets, and a list of _refs_ which are the human names you use to refer to your branches and tags. I recommend poking around the @.git@ directory to see what's inside. Most of it is human readable and very educational.

[Demo: as you're talking about the paragraph above, jump into the .git directory of your repository and just do ls -al so the viewer has a visual reference, or present this as a series of diagrams / graphics]

If you've just started or cloned a git project, you'll find you typically have a branch called _master_. There is nothing special about this branch other than it's the conventional way to name the main development branch -- the rough equivalent of _trunk_ in subversion. Git branches are nothing more than human names for a particular changeset. To verify this, just take a look at the file .git/refs/heads/master. Inside, you'll see the hash that identifies the latest commit in your repository on the master branch.

The _working tree_ is the set of files you're currently working with. To start working on something in your git project, you first @checkout@ a particular branch from your repository. When you checkout code, you specify the name of a branch you'd like to work with, and the files in your working tree are replaced with the files from the branch. The files in your working tree are literally overwritten every time you switch branches by using checkout. If your working tree is dirty (has changes yet to be committed), git will warn you that checking out a particular branch will overwrite your changes and prevent you from doing so. 

There is a place interchangeably known as the index, cache, or staging area. This is where you put your changes before they are ready to be committed to the repository. The index as a place that lets you selectively commit changes you make. For example, if you've made a set of file modifications, but it turns out they are two unrelated changes, you can add the appropriate half first to the index, make the commit, and then add the second half and make another commit.

h2. Setting up your environment

h3. Getting git

This screencast covers features of Git 1.6.3.3 and up. To get git on your system, please read: <a href="http://book.git-scm.com/2_installing_git.html"/>Git Book - Installing Git</a>

Let's get started by making several modifications to a default git setup in order to increase its usability. 

h3. Git bash completion

We don't like extra typing, so let's enable tab completion for git command names and branch names. Locate the file called _git-completion.bash_ and add it to your startup scripts so that it executes. This typically involves adding a line to ~/.bashrc or ~/.bash_profile:

@. /path/to/git-completion.bash@

If you can't locate the file, try http://repo.or.cz/w/git.git?a=blob_plain;f=contrib/completion/git-completion.bash

h3. Show the git branch in your bash prompt

Cheap local branching is one of git's major selling points. Here's a way to show the current git branch in the bash prompt so you don't forget where you are:

If you've enabled the @git-completion.bash@ script from above, you now have a bash function called @__git_ps1@ which displays the current branch. Simply add it to your PS1 line in the place you'd like it to appear

@export PS1='\w$(__git_ps1)$ '@

h3. Useful git aliases

The pdf that comes with this screencast contains a list of git aliases and configurations, to be put in your ~/.gitconfig file. We recommend using all of them, but we'll go over the key ones below:

h3. Get colorized

It's important to make working with git easy on the eyes. Turn on colors to see diffs, status, branches, etc in color. 

<pre>
[color]
  diff = auto
  status = auto
  branch = auto
  interactive = auto
  ui = auto
</pre>

h3. Automatic cleanup and compression of the repo

Git needs periodic maintenance to make it run fast. Here's a way to avoid ever having to think about it by making it run automatically. 

<pre>
[gc]
  auto=1
</pre>

h3. Better merge messages

By default, when you merge a branch in git, you get a fairly meaningless message like _merge branch 'master' of git@github.com:name/project_. To get a bullet point summary of the changes you're merging, turn this option on:

<pre>
[merge]
  summary=true
</pre>

We recommend always editing the merge commit messages by hand, but this at least gives you a good starting point.

It's also handy when doing @cherry-pick@ to copy changes from one branch to another, to have git automatically put the original commit hash into the commit comment. Here's an alias for doing this:

<pre>
[alias]
  cp = cherry-pick -x
</pre>

h3. Better information on branches and remotes

By default, the git @branch@, @remote@, and @tag@ commands give you lists of things, but no information about them. Here are some aliases that do a little better. 

<pre>
[alias]
  b = branch -v
  r = remote -v
  t = tag -l
</pre>

h3. Telling git what to push

We'll talk about pushing and pulling in the remotes chapter, but starting with git 1.6.3, it will warn you heavily if you do not have __push.default__ configured, which tells git what to do when you type 'git push'. Your options are basically 'matching' to push all your branches that match branches on the remote, 'tracking' to push the current branch to whatever branch it's tracking, or 'current' to just push the current branch to the same branch on the remote.

Since the default used to be 'matching', we'll just remove that warning message by recreating this behavior:

<pre>git config push.default matching</pre>


h3. Two useful aliases: unstage and uncommit

There are many other aliases given in the .gitconfig included in the Appendix, but these two are aliases for otherwise hard to remember commands.

<pre>
[alias]
  unstage = reset HEAD
  uncommit = reset --soft HEAD^
</pre>

The powerful @git reset@ command has many different behaviors depending on its command line switches. It can be used to travel in time between changes, throw away your changes, or manipulate the index, or staging area. The @unstage@ and @uncommit@ aliases are two everyday tools we use to manipulate our git workspace.

<code>unstage</code> is effectively the opposite of <code>git add</code>. It lets you remove items from the staging area. This makes it a very useful tool when you're deciding which files to stage for a commit. If you've accidentally added something to the staging area, just use <code>unstage</code> to remove it. 

<code>uncommit</code>, on the other hand, removes the last commit from your repository, and puts the changes into your index. It's like going back in time to the moment right before you committed. This is a useful technique in resuming work on an unfinished changeset. But please don't do it if you've already pushed this changeset to a place where someone may have pulled it from, because you'll be changing the commit history in a nonlinear way. We'll go deeper into usages of this command further in the screencast.

For more aliases, please see the appendix which includes the entire recommended .gitconfig.

h3. Common aliases

Throughout this screencast, we'll be using the following aliases to save on typing. We recommend you use them too. 

 * ci = commit (ci stands for 'check in')
 * co = checkout
 * b = branch
 * nb = checkout -b (create and checkout new branch)
 











h1. Keeping your changesets clean

As developers, we like to keep our code clean so that maintenance is easy. But we often neglect our source control system, making our commits a mess that we hope no one will ever have to untangle. When working with subversion I often experienced myself dumping a day's worth of work into a single commit, no matter how many unrelated changes it contained.

Thanks to git's staging area, cheap local branches, and rebasing features, you can easily keep changeset history as clean and maintainable as your code. Here is the philosophy we will follow:

  * One branch per issue - start a new git branch when working on a
    new feature or bug
  * One feature per commit - each commit should contain code 
    relating to only one issue
  * Branches are named after ticket numbers such as "1234" or   
    "1234-my-feature". You're using a bug tracking system aren't you?
  * All development is done in branches and merged into the _master_ branch. 

Why is it important to keep clean history? First of all, it makes it easy for your fellow developers to see change history in one spot and do simple code reviews without tracking a bug or feature across many commit sets. Second, because it simplifies constructing selective releases on the fly (picking a specific set of bugs and features to be included into a new branch). Learning good changeset hygiene habits saves a lot of development time, and can actually be satisfying in its own right.

h3. Using the staging area for breaking apart quick changes

Before we get to topic branches and keeping different workspace for your bugs and features, let's take a look at a quick way to create separate commits from a single set of changes. 

Let's say you've been hacking away for a couple hours and now you've got two different sets of changes in your working tree. We run @git status@ to see what's available.

[Demo:

  * Create a new project (git init)
  * Create the following file structure:
   * public/file1
   * public/file3
   * file2
   
   Add some random content to the files like "hello world"
   * git add .
   * git commit -m "Initial commit"
  
  * The above could be done behind the scenes. The following is the actual
    meat of the demo:
  
  git status

  # On branch master
  # Changed but not updated:
  #   (use "git add <file>..." to update what will be committed)
  #
  #	modified:   public/file1
  #	modified:   public/file3
  #	modified:   file2
  #
]

On the status screen above we see we have modified two files and added a new file. But it turns out that 'file1' and 'file3' are part of a bugfix, and 'file2' is an unrelated change. You'll see the files shown in red, indicating that they are not yet staged for commit.

We stage a change for commit by adding it to the index. We can ask git to add all of the changes in a particular directory by using the path. Git will automatically add any files that have been changed:

@git add public@

If I wanted to add all available changes I could simply use @git add .@ After running the command, the status shows:

  # On branch master
  # Changes to be committed:
  #   (use "git reset HEAD <file>..." to unstage)
  #
  #	modified:   public/file1
  #	modified:   public/file3
  #
  # Changed but not updated:
  #   (use "git add <file>..." to update what will be committed)
  #
  #	modified:   file2


You'll notice that the files that are added to the index, under "Changes to be committed" are now colored green instead of the previous red. Now to commit the two changes that have been staged, we issue the commit command:

@git ci -m "This is my commit msg"@

Now we're left with the change to file2 in our working tree, and we can follow the same procedure to commit the one file. 

<b>Note:</b> Some beginning git tutorials encourage you to use the syntax @git commit -a -m@ to bypass the index and commit all changes. I recommend _never doing this_ because it is very easy to get lazy and mass commit unrelated changes. Always use _git status_ to find out what's been changed, and selectively add files to the index before committing.

h3. Inspecting staged and unstaged changes

Before committing changes, always verify you're following the one feature per commit philosophy by inspecting the changes that you've staged:

@git diff --staged@

This command will diff the changes staged in the index against the HEAD. This command previously used the switch @--cached@ in older git versions, but has been renamed for consistency. You can also look at the unstaged changes:

@git diff@

This command diffs the unstaged changes against the HEAD. We provide the aliases @d@ for @diff@, and @ds@ for @diff --staged@. You can use these commands to inspect what you're about to commit to make sure the staged changes contain only code relating to one feature or bug.

h3. Using @git add@ for deleted files

A caveat of @git add@ is that it does not take into account deleted files. Typically, git would like you to use @git rm@ to delete files, but in practice, using command line or IDEs you are likely to delete files using traditional methods.

To add deletions to the index, a handy shortcut is @git add -u@, which tells git to add all files it knows about, including deletions. However this syntax does not add new untracked files to the index. So, to add all new, modified, and deleted files, Use @git add .; git add -u@, or the alias provided in the appendix, @git addall@.

h3. Inspecting commits

Once you've made the commit, you can always look at the contents of that specific change by using the @git show@ command. [Demo: use @git show@ to look at the last commit and @git show HEAD^@ to look at the previous commit.]. Note that the special syntax HEAD^ allows us to refer to one commit before the current HEAD. You can add as many carets as you like to refer to N commits ago, or use the syntax HEAD~N.

h3. Staging unrelated changes within one file

Git can also help you tease apart unrelated changes within one file, and add them selectively to the index. I find that I use this rarely because I try to work on separate changes in separate branches, but if you do find yourself in this scenario, git makes it easy:

@git add --patch@

This will launch an interactive prompt which will go through each change in each unstaged file and ask you whether you want to stage the hunk in question. Simply answer the questions, and when you're finished you will see that the file is both in the staged and unstaged areas of the status output.

[Demo:
  * Create a file called README with some contents and commit it
  * Add two lines of text to the file
  * git add --patch
  * Add the first line but not the second
  * Show output of 'git status'
  * Show output of 'git diff' and 'git diff --staged' to compare the staged and unstaged change
]

h3. Using topic branches

When you use a git branch to work on a feature or bug, this is called using a topic branch. You can think of it as a workspace. You can have any number of local workspaces, and switch between them quickly and easily. You may use some to work on particular features, while others may be for experimental code that you will eventually throw away.

h3. One branch per bug

Whenever you start to work on a feature or a bug, create a new branch locally. This branch will live for the duration of the work you do, and then we'll squash it into one clean changeset back into the master, following our _one commit per feature_ philosophy. 

[Demo: 

 @git checkout -b bug123 master@, 

 This command creates and checks out a new branch called bug123, basing it off of the current master branch. 

  Now we work on bug fix 123, making commits as you go. Realize that you actually need to start work on feature456 now.

  @git checkout -b feature456 master@

  Work on feature456, make commits. Now go back to the bug.

  @git checkout bug123@

  Make some more changes. Now we're done, so let's bring these changes back to the master.

  git checkout master
  git merge --squash bug123
  git ci -m "Bug #123 - fixed a typo"
]

Don't you love squashing bugs? The @--squash@ parameter brings in all the commits from the _bug123_ branch as if they were one change. It also avoids logging the change as a merge, so it looks like you just made one clean commit with all the changes from the bug123 branch as one. Once you're sure you don't need the history of working on that bug anymore, delete the branch.

@git branch -D bug123@

I like to use the alias @nb@ for new branch, so that the commands above become:

@git nb feature123 master@

Also note that if you're creating a branch from the branch you're currently on, then the second argument can be omitted, so if you're on the master branch already, simply use:

@git nb feature123@

h3. Coming back to unfinished work on a topic branch

Let's say it's Friday afternoon and you're halfway through a refactoring but you want to save it until next week. A good way to remember that it's unfinished work is to log it in the comments.  Simply commit your changes with a helpful message:

@git ci -a -m "uncommit me: need to finish stuff in the user model"@

Note that above we used the @-a@ switch which tells git to automatically stage all your changes. It's as if you ran @git add .@ right before the commit. When you come in on monday, you can see your list of available branches:

[Demo:
  git b
  * bug123      937c391 uncommit me: need to finish stuff in the user model
]

And remembering that you were working on bug123, you check out the branch to resume work:

@git co bug123@

@git uncommit@

The @uncommit@ alias is covered in Appendix A, and is the aliased to @git reset --soft HEAD^@. Effectively, it takes you back in time to the moment right before you made the commit, with all of your changes still in the index. This means you can now examine your changes and modify them if necessary and commit again.

The nice thing about the @uncommit@ command is that because it leaves your changes staged, and new changes are not staged until you use @git add@, you can easily compare your new changes to the ones from Friday.

h3. Fixing the last commit

The uncommit command above shows you how to resume work on a previously committed changeset. If you're simply adding a couple files or changing the commit comment on your last changeset, a quicker way to do this is

@git ci --amend@, or using the alias @git amend@

As usual, you'll have to @add@ your changes to the index before you do this. The amend command will not create a new commit, instead it will modify the last commit. But a word of caution! Never do this to a commit that you've already pushed to a remote repository. 

When you have a remote tracking branch (we'll get into this later), git will automatically tell you if you have unpushed changes @git status@. You should only use the @uncommit@ and @amend@ features if there is a commit that has not been pushed.

  [Demo: switch to a remote tracking branch, add a commit, and show the output of git status, similar to below:
    git stat
    # On branch 1.2.8
    # Your branch is ahead of 'origin/1.2.8' by 1 commit.
  ]

h3. Using the stash to temporarily hide your changes

Using uncommit is my favorite way of resuming long running work, but if you're working on something and a production bug comes in that takes priority, you can quickly toss your changes into a place git calls the _stash_. You can think of it as a temporary branch that works like a stack. Every time you type @git stash@, your changes are removed from your working tree, restoring your files to the last checked out state, and the changes are saved as a changeset on the stash.

You can then pop your changes off the stash by using @git stash pop@ or @git stash apply@ to apply the change without popping it off the stash. Use @git stash list@ to see the contents of the stash.

<pre>
  # do some work, prod bug comes in
  git stash
  git checkout prod_branch
  # fix your prod bug and commit
  git checkout master
  git stash pop
</pre>

h3. Using the stash to move changes between branches

Another good use of the stash is for moving uncommitted changes between branches. Sometimes you start to work on something, and realize the work probably needs to be moved over to a branch of its own. While you can sometimes checkout another branch and the changes will automatically transfer over, occasionally your changes conflict with the code on the branch, so the correct way to do this is to _stash_ the changes, checkout the new branch, and then unstash them. 

h3. Keeping a topic branch in sync with its parent

When you've wandered off for a while on your topic branch, working on your bug or feature, you'll occasionally want to grab updates that have been made in the master branch, or wherever you branched from. The best way to do this is to use the @rebase@ command. 

<!-- If possible, show a nice diagram of rebase, Scott Chacon's book had good stuff, also shown on whygitisbetterthanx.com -->

What rebase does is rewind your changes, grab the latest from master, and then apply your changes on top. This effectively makes it as if rather than branching several days ago, you just branched now from the tip of the master and made your commits there.

Most of the time, this will work without a hitch. However, you may occasionally get a merge conflict if the same file has been modified in the same place on both branches. 

h3. Resolving conflicts during rebase

If a conflict occurs, git will complain with a very loud and verbose error message. The important thing with git is always to read the end of the message. You will then see that it tells you to resolve the conflict and then @git rebase --continue@ or @git rebase --abort@. 

[Demo:
  Show a rebase conflict. To do this, let's have a project with a README file.
   
   * git nb 1234
   * modify file README, adding a line "hello world"
   * git add .; git ci -m "patched readme file"
   * git co master
   * modify file README, adding line "goodbye world"
   * git add .; git ci -m "patched readme file in a different way"
   * git co 1234
   * Now we try the rebase: git rebase master
   * Show the output (something like the following):
   
   ---   
   Applying: patched readme file
   error: patch failed: README:3
   error: README: patch does not apply
   Using index info to reconstruct a base tree...
   Falling back to patching base and 3-way merge...
   CONFLICT (content): Merge conflict in README
   Failed to merge in the changes.
   Patch failed at 0001.

   When you have resolved this problem run "git rebase --continue".
   If you would prefer to skip this patch, instead run "git rebase --skip".
   To restore the original branch and stop rebasing run "git rebase --abort".   
   ---
   
   Now, show the conflict resolution: open README in your editor, find the lines with <<<< and select the correct line. In this case we'll say the master had the right version and we'll leave it as "goodbye world". 
   
   Run "git status" - note that it will say "Not currently on any branch". This is normal as we're in the middle of a rebase. Make the audience aware of this point, it is very important. 
   
   Run "git add ." to add the README file to the index. Then "git rebase --continue" to finish the rebase.
   
]

If you are ever panicked that something went wrong, just use "git rebase --abort" to go back to the time before you started the rebase. 








h1. Working with logs and history

Now that we've got a handle on working with branches, let's delve a little bit into investigating git history. With git, you've got the entire codebase history in your hands, with no remote server access required, which makes it fast and always available.

h3. Searching for a specific change

If you're looking for a changeset and you remember the change contained the word "hello" but don't remember quite when, you can search for it using the log. The @-p@ parameter tells git to print the actual contents of the patch so you can see the changes. 

@git log -p -S"hello"@

If you know you made the change last week and want to save some time in the search, git understands timeframes in plain english:

@git log -p -S"hello" --since="1 week ago"@

If, on the other hand, you want to search for a commit message (really handy if you put issue tracking numbers into your commit messages, something I highly recommend):

@git log -p --grep="Ticket #382"@

h3. Throwing away all changes

If you've made a mistake and want to go back to the state of HEAD (the last commit made), ignoring anything that's in the working tree or index.

@git reset --hard@

h3. Restoring a file or directory to a past state

Let's say you made some changes to a file (in this case, a README) that just aren't working. Let's throw those away.

@git checkout README@

But what you're really doing here, is checking out the file from your HEAD (equivalent to @git checkout HEAD README@). You can also check out the state of the file from any given commit:

@git checkout c5d563fae README@

Now we've gone and grabbed the file from that particular commit set. Since branches and tags are just labels for particular commit hashes, we can also do the same thing use branch names.

@git checkout experimental_branch README@

But what if you know the file was working last week, now it's broken, and you want to take a look at what it was like? Easy:

<pre>git checkout "@{1 week ago}" README</pre>

When you grab a file from a previous time, it sits in your index, modified. So we can take a look at it:

<pre>
  git status
  
  # On branch master
  # Changes to be committed:
  #   (use "git reset HEAD <file>..." to unstage)
  #
  #	modified:   README
  #
</pre>

And we can see what differences it has with the current version:

@git ds@

We use @ds@ to look at the staged contents (equivalent to @git diff --staged@)

h3. Throwing away commits

We used @git reset --hard@ to reset to the state of HEAD but we can also use it to reset to any state in our repository.

Let's say you committed or pulled in 3 commits and now you realized you no longer want them:

@reset --hard HEAD~3@

This command tells us to revert the repository state to that of 3 commits ago. *Note:* this will effectively throw away your last 3 commits and reset your current branch's HEAD to point to HEAD~3, 3 commits ago. Please be very careful with @git reset --hard@ because it will permanently throw away your changes.

h3. Reverting a changeset

While working with our local repo we have a number of tools including merging, squashing, and interactive rebasing which can help us organize our changes. Once you've pushed changes to a remote repository, it is considered dangerous to modify the history because someone else may have already pulled it. 

However, git offers you an easy way to undo a patch by committing a change that effectively reverses the patch in question. The simplest usage is to revert an entire changeset:

@git revert 850150f@

This creates a patch that is the opposite of changeset 850150f and commits it to your repo.

[Demo:
  * Add a line of text to README file and commit the change
  * Use @git show@ to show the last change
  * Use @git revert HEAD@ to create a reversion commit for that change. Make a note that you can also use @git revert [hash id]@ in the same way.
  * Use @git show@ to show the new commit which reverts the hold
  * Use @git short@ to show the history, and note that the old commit is still there, we just added another commit that reverts it.
  
  And now let's practice throwing away changes completely by throwing away the reversion we just did
  
  * git reset --hard HEAD^
  * Show the current log with @git short@
]

h3. Reverting changes to one file only

This slightly more advanced workflow using @revert@ lets you undo the changes to one file only. We'll do this by asking git to create the reverting changeset but not commit it, and modify it before it goes in. First, we'll figure out which changeset it changed in:

This time we'll ask git to create the reversion changeset, but not commit it, by using the @-n@ switch.

[Demo:
 * Make changes to two files, README and some other file 'foo' and commit them.
 * Now create the reversion change but don't commit it
 * @git revert -n HEAD@ 
 * Show @git status@
]

Since we only want to revert the one file, we'll unstage all the changes.

@git unstage@ 

And now we'll stage just the file we're interested in.

@git add README; get ci -m "Reverting change to README"@

Now we'll just throw away the rest of the changes, which we don't care about:

@git reset --hard@












h1. Remote collaboration and code review

Git is great for remote collaboration because of several factors:
 
* As long as people have read access to your repo, they don't need your permission to clone it and do their own work on their fork. Having their own fork also means they can maintain their own branches without polluting the main repository with personal experimental branches.
* It is easy to pull in work from team mates, and because of cheap branching it's easy to experiment before committing results to the main repository. Because branching is easy, git encourages code review by using branches before the code goes into the master branch.
* GitHub provides an excellent service that helps you track who has cloned your repository and what work they've done. It also offers fantastic per-line code review capabilities.
  
Here we'll take a look at a couple common ways of sharing work using git. This chapter will assume you have an account on GitHub, and that you're using GitHub as your central repository, through which everyone collaborates.

h3. Using git remotes for collaboration

While it's possible to use git completely by yourself, without a remote repo, it's much more useful in a collaborative environment. While there are myriad ways you can use git remotes, I am going to advocate a specific approach that I have found works well:

 * All code is hosted on and shared through GitHub. There will be no peer to peer sharing (grabbing code directly from someone else's repository hosted via git-daemon or similar).
 * Only some team members have direct commit access to your project (we'll call them the _core committers_).
 * Some team members are junior developers or outsourcers whose work is reviewed by and merged in by the core committers (we'll call them _contributors_).
 
This chapter will illustrate how to collaborate on code creation with this sort of team. If your organization uses either a pure core committer model, or pure contributor model, you can still pick and choose the parts of the workflow that make sense to you. 

h3. remote collaboration terminology

Let's take a brief pause here to go over how git remote repositories work. 
Your local git repository may be tied to one or more __remotes__. The __remotes__ may be places you push your code to, or pull changes from. It's even possible to pull from one remote and push to another, albeit unusual.

Since every git repo is a complete mirror, you will find that you have a copy of all the remote work done by your teammates, within your repository. To see all the remote branches, you use @git b -r@. These are are commonly referred to as remote-tracking branches. To do any modification to these branches, you'll have to create local branches, created from the remote tracking branches.

h3. Set up your remote at GitHub

The first thing you'll do is setup your repository on GitHub (http://github.com). If you are working for a company, I recommend setting up the account in the company's name so that contributors know that it's the official repo for the project. Each developer should have his own personal GitHub account (using the free account is fine), which he will use to either contribute directly, or fork the main repo.

Create a new project, and follow GitHub's instructions for pushing your changes out to your newly created repo. If you already have a git repo, the steps typically look like this:

First, add a __remote__ (git's term for a remote repo) called __origin__ (this is simply a convention for the primary repo that you push to and pull from). 

<pre>git remote add origin git@github.com:[username]/[repo-name].git</pre>

You can always see all the remotes you have:

@git remote -v@

Once you have the remote, you'll push the code you have out:

@git push origin master@

This command tells git to push all the changes you've made on your _master_ branch, to the _master_ branch on the remote called _origin_. It's actually a shortcut syntax. Because your local and remote branches are both named __master__, you don't have to specify the remote branch name. If you wanted to call your local branch __foobar__ instead, you could use the syntax

@git push origin foobar:master@

Git offers a secondary shortcut convenience. If you name all your local branches identically to your remotes, then you can just use:

@git push@

This will push out changes on all branches that have matching branches on the remote end.

*Note:* You should take a look at the file called .git/config. This file lists all your branches and remotes, and has interesting information that will help you learn about what git does internally to track your branches and their relationship to remotes. 

h3. git-remote-branch, a handy automation for remote branches

Git is pretty low level when it comes to managing local and remote branches and keeping them in sync. Enter git-remote-branch: a great tool that helps you automate day to day operations on remote branches. As a bonus, it shows you exactly what it's doing under the hood so you can learn more about how git works. The rest of this chapter will assume you have git-remote-branch installed, and are using the @grb@ command.

Homepage: http://github.com/webmat/git_remote_branch/tree/master
Installation (you will need rubygems for this):

@sudo gem install git_remote_branch --include-dependencies@

Once you've installed the tool, go ahead and run @grb@ without arguments to see the help. 

h3. Creating and pushing to remote branches

If you're working on a long lived topic branch for a particular feature, it's a good idea to back it up to your remote. It's also useful to push it out to the remote so that others can look at it and collaborate with you. To push an existing branch to the remote:

@grb share [branchname]@

This pushes your branch out to the remote, and tells git to connect your local branch to the remote-tracking branch, so that when you pull or push, it goes to the right place on the remote.

If you haven't yet created the branch, 

@grb create [branchname]@

Which both creates the local branch and pushes it to the remote. 

h3. When to make remote branches

Typically, if I am working on a quick bug or feature that will be done in less than one day, I don't bother backing it up to the remote, but if there is long running work on a larger feature, I will push it to the remote, not only for backup purposes, but also so that I can get my code peer reviewed by my team.

h3. Deleting a remote branch

If you've worked for several days on an experimental branch that you pushed to the remote, and then decided to throw it away, or perhaps you merged it into your master branch and no longer need it as a standalone branch, you can delete it locally with:

@git branch -D [branchname]@

But your branch is still alive on the remote. To delete it, git has a slightly obscure syntax

@git push origin :[branchname]@

Of course, @grb@ makes it simpler to do both in one shot

@grb delete [branchname]@

But if you never officially merged this branch (say you merged it via squashing), grb will complain because it does not autodelete unmerged local branches. So you will have to follow up with the @git branch -D [branchname]@ syntax to force delete the local tracking branch.

h3. Pulling changes from a remote

The opposite of push is a pull, and allows you to grab code that someone else has committed. The pull is done in two steps. The first step, @fetch@, downloads code from the remote repo into your local git repo (the directory called _.git_, NOT your working tree). 

The second step is getting the changes from the remote branch into your local working tree by using either @merge@ or @rebase@. Let's take a look at how this works.

Suppose you're working on a branch called _bug123_ at your github repository. A coworker has committed changes to the branch that you wish to pull in.

First, we fetch the latest changes from the remote repo. This will download __everything__ in the remote repo into our local repo. This includes all remote branches. Remember that with git, you're storing the entire repository locally.

@git fetch origin@

To show all the branches we now have, use:

@git branch -av@

The @-a@ tells us we want to see all branches (including remote ones, you can see _only_ remote branches by using @-r@), and the @-v@ gives us information about the latest change on each branch. 

If you ever try to check out a remote-tracking branch directly:

@git checkout origin/master@

You will get a warning from git that looks like this:

<pre>
  Note: moving to "origin/master" which isn't a local branch
  If you want to create a new branch from this checkout, you may do so
  (now or later) by using -b with the checkout command again. Example:
    git checkout -b <new_branch_name>
</pre>

So in order to actually work with the remote branch, we'll need a local tracking branch set up to track the remote branch in question:

Using @git-remote-branch@, the command is very straightforward:
@grb track bug123@

@Branch bug123 set up to track remote branch refs/remotes/origin/master.@


h3. Pulling changes using merge

Once you've fetched all the remote branches and opened up the local tracking branch you want to work with, you'll merge the latest changes from the remote:

@git merge origin/bug123@

To automate the fetch and merge steps, git offers a @pull@ command that does both in one shot:

@git pull origin bug123@

*Note:* whenever you merge, a commit message will be left in your local repo indicating the merge. This is because to git, there is no such thing as a central repo. Even if you and your team are using github to collaborate, each of your individual repos is treated as an equal, and merges are logged there just as they are anywhere else. 

When working on long lived branches where multiple developers are constantly syncing up to it, I dislike merge commits because they dirty your repo history with essentially meaningless messages. To avoid this, we can use rebase instead.

h3. Long lived remote collaboration using rebase

Remember @git rebase@? This command lets you move your work to the tip of a branch as if you had just started the work from the tip. This can be used to keep in sync with a remote repo as well. Let's say you've been working on your branch _bug123_ and have made 3 commits. Meanwhile your coworker has pushed 2 commits to _origin/bug123_ (at github). 

You can grab his changes, and replay your changes on top by using the same rebase technique:

@git fetch origin; git rebase origin/bug123@

There is no difference between this and using rebase on your local branches, other than that we're rebasing from a remote tracking branch. Git also offers a shortcut to pull in this manner:

@git pull --rebase origin bug123@

If this is the way you prefer to work, you can have git always rebase instead of merge your pulls by editing your _.git/config_ file for the branch in question:

<pre>
[branch "master"]
  remote = origin
  merge = refs/heads/master
  rebase = true
</pre>

*Note:* as before, make sure you understand what you're doing with rebase. It will rewrite your commit hashes, so if you've pushed your code out to one place and rebase from another, you'll be in trouble. However, if you use rebase as recommended here, to sync with only one central (GitHub) repository, you will have no problems.


h3. Core committer collaboration workflow

So, now that we know how to use @git pull --rebase@, let's take a look at a typical scenario in collaboration between two core committers, Alice and Bob, who work for BugFreeCode, Inc. working on a bug together:

 1. Alice creates a branch and makes commits
 2. Bob pulls her changes and makes additions
 3. Alice pulls Bob's changes
 4. Alice squashes bug into master and closes the branch

Alice starts working:

<pre>
grb create bug123
# hack, hack, hack
git ci -a -m "Bug #123 fixed, needs code review"
git push origin bug123
</pre>

She then asks Bob to do a code review on the branch. Bob pulls in Alice's changes:

<pre>
git nb bug123 origin/bug123 # first time only
git co bug123; git pull --rebase origin bug123 # to sync it up
# hack, hack, hack
git ci -a -m "Bug #123 - Cleaned up alice's code"
git push origin bug123
</pre>

Alice, who is the owner of the bug, now decides the bug is good to go, and merges it into the _master_ branch, which their team uses as a starting place to create releases. 

<pre>
git co bug123
git pull --rebase origin bug123
git co master
git merge --squash bug123
git ci -m "Bug #123 - fixed all sorts of stuff. Thanks to Bob for the help."
git push # update the remote master branch
</pre>

Since the bug is now in master, if there is no long term need to keep its history around, Alice deletes the branch from her local repo, and the remote.

@grb delete bug123@

h3. Squashing for code review

If Alice has made ten changes while working on her new feature, we'll call _feature-x_, and she wants her team to review her work, it is easier to review it as one cohesive changeset. While the _bug123_ branch is still useful to track the history of the work on the bug as she debugs it with Bob, she only wants to show the one finalized changeset:

Using the @merge --squash@ technique discussed in Chapter 1, we can create a changeset that will combine all her changes into one. By pushing this changeset out to GitHub, you can get a nice way to do code review with GitHub's line-by-line comment feature.

I like to add _-squashed_ to the end of the branch name so that I know it's a temporary branch meant just for reviewing commits. Below, we create a branch called _bug123-squashed_, branched from _master_, and create a squashed changeset, pushing it out to GitHub.

<pre>
grb create bug123-squashed
git merge --squash origin/bug123@
git commit -m "Bug #123 - squashed commit for code review"
git push
</pre>

Now, Alice can refer her team to the GitHub url for the changeset, and collect comments using the web interface at GitHub, or coworkers can directly checkout the _bug123-squashed_ branch and use @diff@ and @show@ commands to inspect it.

h3. Outside contributor collaboration workflow

While Alice and Bob work together by directly committing to the GitHub repo, they outsource part of their project to contributor Charlie. Alice is the project leader, so she takes on the primary task of reviewing Charlie's work, and merging it into the main repository.

The workflow recommended for outside contributors is as follows, using Alice as an official core committer, and Charlie as the contributor

1. Charlie creates a branch for every feature or bug
2. Charlie has a remote repo link to the official repo 
3. Alice examines code committed by Charlie, adds her own changes
5. Alice merges Charlie's changes into the official __master__
6. Charlie pulls changes from official _master_ into his own _master_

You already have all the tools you need to execute this workflow. Let's walk through it.

h3. Setting up remote contributor forks

First, Charlie signs up for his own GitHub account. He then visits the project's homepage under the company's GitHub account, and clicks the Fork button. This button creates a clone of the repo for Charlie under his own account.

GitHub offers a nice feature for fork network tracking and visualization which is probably worth the price of admission alone. The company can now look at who has forked the project, and what kind of commits they have made. This makes it easy to know when something is worth pulling in.

Once Charlie has his fork, he follows the instructions provided by GitHub to clone the fork on his local machine, which looks something like this:

<pre>git clone git@github.com:charlie/some-project.git</pre>

Charlie now has an _origin_ which refers to his own project on GitHub. But he's going to occasionally want to sync up to the official repo owned by BugFreeCode, Inc, so he'll add a remote for the original repo, as well:

<pre>git remote add bugfree git@github.com:bugfreecode-inc/some-project.git</pre>

h3. Taking a look at contributor's work

To track Charlie's progress, Alice sets up a remote link to Charlie's repo:

@git remote add charlie git@github.com:charlie/some-project.git; git fetch charlie@

She can then directly view branches using

@git show charlie/bug123@

Or, by using the techniques from the beginning of the chapter to create local tracking branches for contributing to Charlie's work:

<pre>
  git nb bug123 charlie/bug123
  # hack, hack, hack - helping charlie out
  git ci -a -m "code review and fixing to help Charlie"
  git push charlie bug123

  # once the bug is done, put it into master
  git co master
  git merge --squash charlie bug123
  git ci -m "Bug #123 - fix something" --author "Charlie <charlie@charlie.com>"
  git push
</pre>

Charlie keeps himself in sync to the official master branch by using @pull --rebase@:

<pre>
  git co master
  git pull --rebase bugfreecode master
</pre>

If Charlie does all his work on branches and never touches his master, another equivalent way, but perhaps slightly safer (avoiding any rebase troubles), is to reset to point to the master
<pre>
  git co master
  git fetch bugfreecode; git reset --hard bugfreecode/master
</pre>

h3. Giving credit to contributors

In the section above, notice the @--author@ switch on the commit line. Git understands that the person committing is not always the person who wrote the code. By using this line, you will see the commit appear on GitHub with two users attached to it, which is a great way to give credit and track the real owner of the code for the future.

The nice thing is that git remembers authors, and you can use pattern matching in the future to specify an author. So to designate Charlie as the author, you can use @--author "cha"@ in the future.

h3. Cleaning up stale remote tracking branches

Once you're finished collaborating on remote branch bug123, one of the developers will delete the remote branch, but everyone else will still have that branch listed in their @git branch -a@ output. To remove any stale tracking branches that are already gone from the remote, simply use

@git remote prune origin@

Where _origin_ is the name of the remote. Do this for every remote you have periodically to maintain a clean branch list.

h3. Dealing with conflicts during merges

When you merge another branch, you may occasionally get a CONFLICT if the code in the same place has been modified in ways that git cannot easily merge. Git will provide a warning message

<pre>
  git merge --squash origin/bugfix
  CONFLICT (content): Merge conflict in app/models/foo.rb
</pre>

There are two ways to deal with conflicts. I've found the easiest thing is to simply open up the file in question, and find the conflicting section. It will look something like this:

<pre>
<<<<<<< HEAD:app/models/foo.rb
  your_line_of_code_
=======
  new_line_of_code_from_remote
>>>>>>> origin/bugfix:app/models/foo.rb
</pre>

Simply edit the file to remove the "<<<" and ">>>" markers, leaving the correct line of code in place. The other way to do this is to run @git mergetool@. This command will automatically launch whatever available merging utility you have on your system (typically FileMerge on OSX), and give you a graphical UI for picking one line or another. It's really a matter of personal preference but after some experience I found it's actually easier to understand the changes by looking at the file directly.

You'll also notice that the conflicted file didn't get added to the index, so once you've resolved all your conflicts, simply

@git add .@

To add all the changes to your index, and commit.

h3. Dealing with conflicts during rebase

TODO/UNFINISHED: rebase conflict management. git rebase --abort/--continue etc.

http://jdwyah.blogspot.com/2008/09/merging-with-git-conflicts.html


h3. Bonus: Serving up your local repo to a friend

While I strongly advocate using a centralized repo service like GitHub, sometimes you just have a local project you want to share with a friend or two. You can fire up a git repository server very quickly using the following command:

@git daemon --reuseaddr --verbose --export-all --base-path=/path/to/root/of/repos@

Your friend will then add the repo in question to his remotes

@git remote add somerepo git://your.ip.address/project-folder-name; git fetch@

Please see the @git help daemon@ for further discussion on this topic.
















<!-- ADVANCED STUFF, SAVE FOR END OF SCREENCAST, NOT DONE-->


h3. ADVANCED: Changing commit history to clean up change sets

*WARNING:* you should never alter commit history after you have pushed your changes to a remote repository.

If you've been following the above techniques and keeping your work in separate branches, squashing full changesets into master, you'll hopefully never have to do interactive rebasing. However, one scenario where this technique is useful is when you've pulled a large set of changes from another repo (more on working with others later in the screencast). 

Your friend may not have been following the clean changeset philosophy as you have, so you'd like to fix the commits you just pulled from him by fixing some commit messages, maybe edit some of the code in one of the commits, and perhaps combining some of his commits into larger changesets.

The @rebase -i@ command is a powerful way to gain editorial capabilities over your last N commits. To launch it, use the following syntax:

@git rebase -i [commit to start with]@

The main argument to this command can either be a specific commit hash, or you can use the special HEAD^ for the previous commit, or HEAD~N syntax to refer to the HEAD at N commits ago.

Once you have done this, you'll be presented with an editor screen with instructions. It will look something like this:

[Demo:
  Before this demo starts, make sure you've made at least four commits to the README or some other file in the demo source tree so that there is something to rebase. We'll also be doing the work on a temporary branch so as not to mess up our master. Let's first create the temp branch.
  
  git nb temp master
  
  Launch the rebase for the last 3 commits with 
  
  git rebase -i HEAD~3

 Show the output, which looks something like this:
<pre>
  pick 06e0e1a some change
  pick 850150f another change
  pick 737b01b foo bar baz

  # Rebase 5926a38..737b01b onto 5926a38
  #
  # Commands:
  #  pick = use commit
  #  edit = use commit, but stop for amending
  #  squash = use commit, but meld into previous commit
  #
  # If you remove a line here THAT COMMIT WILL BE LOST.
</pre>
]

Something to note is that the commits are actually presented in chronological order, with the latest commit on the bottom. This is counter to most of git's displays of commits (for example, the 'git log' command displays the most recent commit on top).

The screen offers a clean set of instructions to follow. The interactive rebase enables you to do three basic things: delete commits, edit commits, and squash several commits together into one. The most common and straighforward usecase is to squash commits. We do not recommend using the edit feature, as it is confusing and easy to make a mistake, however for those who are interested, interactive rebase editing will be covered at the end of the screencast.

As before, if you decide you've made a mistake and want to abandon your rebasing, simply use @git rebase --abort@. Another way to stop a rebase is when you're looking at the rebase editing screen, delete everything on it and exit.

We'll start by looking at our current commit history. 

[Demo:
  For this demo, first make four changes to the README file, something simple like adding a line each time and commit in four different commits.

  @git short@

  Show the output:
  
  017df6c 52 seconds ago yan Change four
  0ece00d 87 seconds ago yan Change three
  2c870e2 2 minutes ago yan Change two
  7de7832 2 minutes ago yan First change
]

The @short@ command is an alias for a nicely formatted set of changes that's a little easier to read than git's default log output. Let's say we now want to squash changes two and three into one, since they're actually work on the same bug.

[Demo:

  git rebase -i HEAD~3

  You are presented with a screen like this:
  
  pick 2c870e2 Change two
  pick 0ece00d Change three
  pick 017df6c Change four

  Now we'll squash change three into change two:
  
  pick 2c870e2 Change two
  squash 0ece00d Change three
  pick 017df6c Change four

  Save and exit the screen. We are now presented with a commit screen for the newly squashed changes. We will make the commit message "Change two and Change three". Save and quit the editor. Show output:
  
  [detached HEAD]: created 02521cf: "Change two and Change three"
   1 files changed, 2 insertions(+), 0 deletions(-)
  Successfully rebased and updated refs/heads/master.
  
  Now, the 'proof', show the output of 'git short' again.
  
  ac56fcb 18 seconds ago yan Change four
  02521cf 58 seconds ago yan Change two and Change three
  7de7832 12 minutes ago yan First change
  
  We can also use "git show 02521cf" to verify that the change looks like we expect it to.
]


You can learn more about interactive rebasing here: <a href="http://book.git-scm.com/4_interactive_rebasing.html">http://book.git-scm.com/4_interactive_rebasing.html</a>


h3. Editing during interactive rebase

[Demo:
 Do the interactive rebase, and change the second commit to "edit".
 TODO: FINISH THIS SECTION
]