h1. What this screencast covers

Welcome to the Git Workflows screencast. In this video we'll take a look at how to use the Git version control system to improve your development efficiency, maintain clean changeset history, increase collaboration, and bring git into your workplace.

This screencast assumes a basic familiarity with git, and encourages a specific workflow and development philosophy. While we won't cover all the possible usages of each git command (there are way too many), we'll give you what we feel are the best ways to make git a useful tool in your daily development workflow.

If you haven't been exposed to git, we recommend checking out the following links:

* http://whygitisbetterthanx.com/ - with great diagrams showing not only how the git repos work, but also some of the workflows we'll discuss in this screencast.
* <a href="http://peepcode.com/products/git-internals-pdf">Git Internals by Scott Chacon, published by Peepcode</a>

h2. Setting up your environment

Let's get started by making several modifications to a default git setup in order to increase its usability. 

h3. Git bash completion

We don't like extra typing, so let's enable tab completion for git command names and branch names. Locate the file called _git-completion.bash_ and add it to your startup scripts so that it executes. This typically involves adding a line to ~/.bashrc or ~/.bash_profile:

@. /path/to/git-completion.bash@

If you can't locate the file, try http://repo.or.cz/w/git.git?a=blob_plain;f=contrib/completion/git-completion.bash

h3. Show the git branch in your bash prompt

Cheap local branching is one of git's major selling points. Here's a way to show the current git branch in the bash prompt so you don't forget where you are:

If you've enabled the @git-completion.bash@ script from above, you now have a bash function called @__git_ps1@ which displays the current branch. Simply add it to your PS1 line in the place you'd like it to appear

@export PS1='\w$(__git_ps1)$ '@

h3. Useful git aliases

The pdf that comes with this screencast contains a list of git aliases and configurations, to be put in your ~/.gitconfig file. We recommend using all of them, but we'll go over the key ones below:

h3. Get colorized

It's important to make working with git easy on the eyes. Turn on colors to see diffs, status, branches, etc in color. 

<pre>
[color]
  diff = auto
  status = auto
  branch = auto
  interactive = auto
  ui = auto
</pre>

h3. Automatic cleanup and compression of the repo

Git needs periodic maintenance to make it run fast. Here's a way to avoid ever having to think about it by making it run automatically. 

<pre>
[gc]
  auto=1
</pre>

h3. Better merge messages

By default, when you merge a branch in git, you get a fairly meaningless message like _merge branch 'master' of git@github.com:name/project_. To get a bullet point summary of the changes you're merging, turn this option on:

<pre>
[merge]
  summary=true
</pre>

We recommend always editing the merge commit messages by hand, but this at least gives you a good starting point.

It's also handy when doing @cherry-pick@ to copy changes from one branch to another, to have git automatically put the original commit hash into the commit comment. Here's an alias for doing this:

<pre>
[alias]
  cp = cherry-pick -x
</pre>

h3. Better information on branches and remotes

By default, the git @branch@, @remote@, and @tag@ commands give you lists of things, but no information about them. Here are some aliases that do a little better. 

<pre>
[alias]
  b = branch -v
  r = remote -v
  t = tag -l
</pre>

h3. Two useful aliases: unstage and uncommit

There are many other aliases given in the .gitconfig included in the Appendix, but these two are aliases for otherwise hard to remember commands.

<pre>
[alias]
  unstage = reset HEAD
  uncommit = reset --soft HEAD^
</pre>

The powerful @git reset@ command has many different behaviors depending on its command line switches. It can be used to travel in time between changes, throw away your changes, or manipulate the index, or staging area. The @unstage@ and @uncommit@ aliases are two everyday tools we use to manipulate our git workspace.

<code>unstage</code> is effectively the opposite of <code>git add</code>. It lets you remove items from the staging area. This makes it a very useful tool when you're deciding which files to stage for a commit. If you've accidentally added something to the staging area, just use <code>unstage</code> to remove it. 

<code>uncommit</code>, on the other hand, removes the last commit from your repository, and puts the changes into your index. It's like going back in time to the moment right before you committed. This is a useful technique in resuming work on an unfinished changeset. But please don't do it if you've already pushed this changeset to a place where someone may have pulled it from, because you'll be changing the commit history in a nonlinear way. We'll go deeper into usages of this command further in the screencast.

For more aliases, please see the appendix which includes the entire recommended .gitconfig.

h3. Common aliases

Throughout this screencast, we'll be using the following aliases to save on typing. We recommend you use them too. 

 * ci = commit (ci stands for 'check in')
 * co = checkout
 * b = branch
 * nb = checkout -b (create and checkout new branch)
 











h1. Keeping your changesets clean

As developers, we like to keep our code clean so that maintenance is easy. But we often neglect our source control system, making our commits a mess that we hope no one will ever have to untangle. When working with subversion I often experienced myself dumping a day's worth of work into a single commit, no matter how many unrelated changes it contained.

Thanks to git's staging area, cheap local branches, and rebasing features, you can easily keep changeset history as clean and maintainable as your code. Here is the philosophy we will follow:

  * One branch per issue - start a new git branch when working on a
    new feature or bug
  * One feature per commit - each commit should contain code 
    relating to only one issue
  * Branches are named after ticket numbers such as "1234" or   
    "1234-my-feature". You're using a bug tracking system aren't you?
  * All development is done in branches and merged into the _master_ branch. 

Why is it important to keep clean history? First of all, it makes it easy for your fellow developers to see change history in one spot and do simple code reviews without tracking a bug or feature across many commit sets. Second, because it simplifies constructing selective releases on the fly (picking a specific set of bugs and features to be included into a new branch). Learning good changeset hygiene habits saves a lot of development time, and can actually be satisfying in its own right.

h3. Using the staging area for breaking apart quick changes

Before we get to topic branches and keeping different workspace for your bugs and features, let's take a look at a quick way to create separate commits from a single set of changes. 

Let's say you've been hacking away for a couple hours and now you've got two different sets of changes in your working tree. We run @git status@ to see what's available.

[Demo:

  * Create a new project (git init)
  * Create the following file structure:
   * public/file1
   * public/file3
   * file2
   
   Add some random content to the files like "hello world"
   * git add .
   * git commit -m "Initial commit"
  
  * The above could be done behind the scenes. The following is the actual
    meat of the demo:
  
  git status

  # On branch master
  # Changed but not updated:
  #   (use "git add <file>..." to update what will be committed)
  #
  #	modified:   public/file1
  #	modified:   public/file3
  #	modified:   file2
  #
]

On the status screen above we see we have modified two files and added a new file. But it turns out that 'file1' and 'file3' are part of a bugfix, and 'file2' is an unrelated change. You'll see the files shown in red, indicating that they are not yet staged for commit.

We stage a change for commit by adding it to the index. We can ask git to add all of the changes in a particular directory by using the path. Git will automatically add any files that have been changed:

@git add public@

If I wanted to add all available changes I could simply use @git add .@ After running the command, the status shows:

<pre>
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   public/file1
#	modified:   public/file3
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#	modified:   file2
</pre>

You'll notice that the files that are added to the index, under "Changes to be committed" are now colored green instead of the previous red. Now to commit the two changes that have been staged, we issue the commit command:

@git ci -m "This is my commit msg"@

Now we're left with the change to file2 in our working tree, and we can follow the same procedure to commit the one file. 

<b>Note:</b> Some beginning git tutorials encourage you to use the syntax @git commit -a -m@ to bypass the index and commit all changes. I recommend _never doing this_ because it is very easy to get lazy and mass commit unrelated changes. Always use _git status_ to find out what's been changed, and selectively add files to the index before committing.

h3. Inspecting staged and unstaged changes

Before committing changes, always verify you're following the one feature per commit philosophy by inspecting the changes that you've staged:

@git diff --staged@

This command will diff the changes staged in the index against the HEAD. This command previously used the switch @--cached@ in older git versions, but has been renamed for consistency. You can also look at the unstaged changes:

@git diff@

This command diffs the unstaged changes against the HEAD. We provide the aliases @d@ for @diff@, and @ds@ for @diff --staged@. You can use these commands to inspect what you're about to commit to make sure the staged changes contain only code relating to one feature or bug.

h3. Using @git add@ for deleted files

A caveat of @git add@ is that it does not take into account deleted files. Typically, git would like you to use @git rm@ to delete files, but in practice, using command line or IDEs you are likely to delete files using traditional methods.

To add deletions to the index, a handy shortcut is @git add -u@, which tells git to add all files it knows about, including deletions. However this syntax does not add new untracked files to the index. So, to add all new, modified, and deleted files, Use @git add .; git add -u@, or the alias provided in the appendix, @git addall@.

h3. Inspecting commits

Once you've made the commit, you can always look at the contents of that specific change by using the @git show@ command. [Demo: use @git show@ to look at the last commit and @git show HEAD^@ to look at the previous commit.]. Note that the special syntax HEAD^ allows us to refer to one commit before the current HEAD. You can add as many carets as you like to refer to N commits ago, or use the syntax HEAD~N.

h3. Staging unrelated changes within one file

Git can also help you tease apart unrelated changes within one file, and add them selectively to the index. I find that I use this rarely because I try to work on separate changes in separate branches, but if you do find yourself in this scenario, git makes it easy:

@git add --patch@

This will launch an interactive prompt which will go through each change in each unstaged file and ask you whether you want to stage the hunk in question. Simply answer the questions, and when you're finished you will see that the file is both in the staged and unstaged areas of the status output.

[Demo:
  * Create a file called README with some contents and commit it
  * Add two lines of text to the file
  * git add --patch
  * Add the first line but not the second
  * Show output of 'git status'
  * Show output of 'git diff' and 'git diff --staged' to compare the staged and unstaged change
]

h3. Using topic branches

When you use a git branch to work on a feature or bug, this is called using a topic branch. You can think of it as a workspace. You can have any number of local workspaces, and switch between them quickly and easily. You may use some to work on particular features, while others may be for experimental code that you will eventually throw away.

h3. One branch per bug

Whenever you start to work on a feature or a bug, create a new branch locally. This branch will live for the duration of the work you do, and then we'll squash it into one clean changeset back into the master, following our _one commit per feature_ philosophy. 

[Demo: 

 @git checkout -b bug123 master@, 

 This command creates and checks out a new branch called bug123, basing it off of the current master branch. 

  Now we work on bug fix 123, making commits as you go. Realize that you actually need to start work on feature456 now.

  @git checkout -b feature456 master@

  Work on feature456, make commits. Now go back to the bug.

  @git checkout bug123@

  Make some more changes. Now we're done, so let's bring these changes back to the master.

  git checkout master
  git merge --squash bug123
  git ci -m "Bug #123 - fixed a typo"
]

Don't you love squashing bugs? The @--squash@ parameter brings in all the commits from the _bug123_ branch as if they were one change. It also avoids logging the change as a merge, so it looks like you just made one clean commit with all the changes from the bug123 branch as one. Once you're sure you don't need the history of working on that bug anymore, delete the branch.

@git branch -D bug123@

I like to use the alias @nb@ for new branch, so that the commands above become:

@git nb feature123 master@

Also note that if you're creating a branch from the branch you're currently on, then the second argument can be omitted, so if you're on the master branch already, simply use:

@git nb feature123@

h3. Coming back to unfinished work on a topic branch

Let's say it's Friday afternoon and you're halfway through a refactoring but you want to save it until next week. A good way to remember that it's unfinished work is to log it in the comments.  Simply commit your changes with a helpful message:

@git ci -a -m "uncommit me: need to finish stuff in the user model"@

Note that above we used the @-a@ switch which tells git to automatically stage all your changes. It's as if you ran @git add .@ right before the commit. When you come in on monday, you can see your list of available branches:

[Demo:
  git b
  * bug123      937c391 uncommit me: need to finish stuff in the user model
]

And remembering that you were working on bug123, you check out the branch to resume work:

@git co bug123@

@git uncommit@

The @uncommit@ alias is covered in Appendix A, and is the aliased to @git reset --soft HEAD^@. Effectively, it takes you back in time to the moment right before you made the commit, with all of your changes still in the index. This means you can now examine your changes and modify them if necessary and commit again.

The nice thing about the @uncommit@ command is that because it leaves your changes staged, any new changes you make can be compared to the old ones because they will be unstaged at first.

h3. Fixing the last commit

The uncommit command above shows you how to resume work on a previously committed changeset. If you're simply adding a couple files or changing the commit comment on your last changeset, a quicker way to do this is

@git ci --amend@, or using the alias @git amend@

As usual, you'll have to @add@ your changes to the index before you do this. The amend command will not create a new commit, instead it will modify the last commit. But a word of caution! Never do this to a commit that you've already pushed to a remote repository. 

h3. Using the stash to temporarily hide your changes

Using uncommit is my favorite way of resuming long running work, but if you're working on something and a production bug comes in that takes priority, you can quickly toss your changes into a place git calls the _stash_. You can think of it as a temporary branch that works like a stack. Every time you type @git stash@, your changes are removed from your working tree, restoring your files to the last checked out state, and the changes are saved as a changeset on the stash.

You can then pop your changes off the stash by using @git stash pop@ or @git stash apply@ to apply the change without popping it off the stash. Use @git stash list@ to see the contents of the stash.

<pre>
  # do some work, prod bug comes in
  git stash
  git checkout prod_branch
  # fix your prod bug and commit
  git checkout master
  git stash pop
</pre>

h3. Using the stash to move changes between branches

Another good use of the stash is for moving uncommitted changes between branches. Sometimes you start to work on something, and realize the work probably needs to be moved over to a branch of its own. While you can sometimes checkout another branch and the changes will automaticaly transfer over, occasionally your changes conflict with the code on the branch, so the correct way to do this is to _stash_ the changes, checkout the new branch, and then unstash them. 

h3. Keeping a topic branch in sync with its parent

When you've wandered off for a while on your topic branch, working on your bug or feature, you'll occasionally want to grab updates that have been made in the master branch, or wherever you branched from. The best way to do this is to use the @rebase@ command. 

<!-- If possible, show a nice diagram of rebase, Scott Chacon's book had good stuff, also shown on whygitisbetterthanx.com -->

What rebase does is rewind your changes, grab the latest from master, and then apply your changes on top. This effectively makes it as if rather than branching several days ago, you just branched now from the tip of the master and made your commits there.

Most of the time, this will work without a hitch. However, you may occasionally get a merge conflict if the same file has been modified in the same place on both branches. 

h3. Resolving conflicts during rebase

If a conflict occurs, git will complain with a very loud and verbose error message. The important thing with git is always to read the end of the message. You will then see that it tells you to resolve the conflict and then @git rebase --continue@ or @git rebase --abort@. 

[Demo:
  Show a rebase conflict. To do this, let's have a project with a README file.
   
   * git nb 1234
   * modify file README, adding a line "hello world"
   * git add .; git ci -m "patched readme file"
   * git co master
   * modify file README, adding line "goodbye world"
   * git add .; git ci -m "patched readme file in a different way"
   * git co 1234
   * Now we try the rebase: git rebase master
   * Show the output (something like the following):
   
   ---   
   Applying: patched readme file
   error: patch failed: README:3
   error: README: patch does not apply
   Using index info to reconstruct a base tree...
   Falling back to patching base and 3-way merge...
   CONFLICT (content): Merge conflict in README
   Failed to merge in the changes.
   Patch failed at 0001.

   When you have resolved this problem run "git rebase --continue".
   If you would prefer to skip this patch, instead run "git rebase --skip".
   To restore the original branch and stop rebasing run "git rebase --abort".   
   ---
   
   Now, show the conflict resolution: open README in your editor, find the lines with <<<< and select the correct line. In this case we'll say the master had the right version and we'll leave it as "goodbye world". 
   
   Run "git status" - note that it will say "Not currently on any branch". This is normal as we're in the middle of a rebase. Make the audience aware of this point, it is very important. 
   
   Run "git add ." to add the README file to the index. Then "git rebase --continue" to finish the rebase.
   
]

If you are ever panicked that something went wrong, just use "git rebase --abort" to go back to the time before you started the rebase. 








h1. Working with logs and history

Now that we've got a handle on working with branches, let's delve a little bit into investigating git history. With git, you've got the entire codebase history in your hands, with no remote server access required, which makes it fast and always available.

h3. Searching for a specific change

If you're looking for a changeset and you remember the change contained the word "hello" but don't remember quite when, you can search for it using the log. The @-p@ parameter tells git to print the actual contents of the patch so you can see the changes. 

@git log -p -S"hello"@

If you know you made the change last week and want to save some time in the search, git understands timeframes in plain english:

@git log -p -S"hello" --since="1 week ago"@

If, on the other hand, you want to search for a commit message (really handy if you put issue tracking numbers into your commit messages, something I highly recommend):

@git log -p --grep="Ticket #382"@

h3. Throwing away all changes

If you've made a mistake and want to go back to the state of HEAD (the last commit made), ignoring anything that's in the working tree or index.

@git reset --hard@

h3. Restoring a file or directory to a past state

The most basic type of time traveling is grabbing a set of changes from your HEAD. Let's say you made some changes to a file (in this case, a README) that just aren't working. Let's throw those away.

@git checkout README@

But what you're really doing here, is checking out the file from your HEAD (equivalent to @git checkout HEAD README@). You can also check out the state of the file from any given commit:

@git checkout c5d563fae README@

Now we've gone and grabbed the file from that particular commit set. Since branches and tags are just labels for particular commit hashes, we can also do the same thing use branch names.

@git checkout experimental_branch README@

But what if you know the file was working last week, now it's broken, and you want to take a look at what it was like? Easy:

<pre>git checkout "@{1 week ago}" README</pre>

When you grab a file from a previous time, it sits in your index, modified. So we can take a look at it:

<pre>
  git status
  
  # On branch master
  # Changes to be committed:
  #   (use "git reset HEAD <file>..." to unstage)
  #
  #	modified:   README
  #
</pre>

And we can see what differences it has with the current version:

@git ds@

We use @ds@ to look at the staged contents (equivalent to @git diff --staged@)

h3. Throwing away commits

We used @git reset --hard@ to reset to the state of HEAD but we can also use it to reset to any state in our repository.

Let's say you committed or pulled in 3 commits and now you realized you no longer want them:

@reset --hard HEAD~3@

This command tells us to revert the repository state to that of 3 commits ago. *Note:* this will effectively throw away your last 3 commits and reset your current branch's HEAD to point to HEAD~3, 3 commits ago. Please be very careful with @git reset --hard@ because it will permanently throw away your changes.

h3. Reverting a changeset

While working with our local repo we have a number of tools including merging, squashing, and interactive rebasing which can help us organize our changes. Once you've pushed changes to a remote repository, it is considered dangerous to modify the history because someone else may have already pulled it. 

However, git offers you an easy way to undo a patch by committing a change that effectively reverses the patch in question. The simplest usage is to revert an entire changeset:

@git revert 850150f@

This creates a patch that is the opposite of changeset 850150f and commits it to your repo.

[Demo:
  * Add a line of text to README file and commit the change
  * Use @git show@ to show the last change
  * Use @git revert HEAD@ to create a reversion commit for that change. Make a note that you can also use @git revert [hash id]@ in the same way.
  * Use @git show@ to show the new commit which reverts the hold
  * Use @git short@ to show the history, and note that the old commit is still there, we just added another commit that reverts it.
  
  And now let's practice throwing away changes completely by throwing away the reversion we just did
  
  * git reset --hard HEAD^
  * Show the current log with @git short@
]

h3. Reverting changes to one file only

This slightly more advanced workflow using @revert@ lets you undo the changes to one file only. We'll do this by asking git to create the reverting changeset but not commit it, and modify it before it goes in. First, we'll figure out which changeset it changed in:

This time we'll ask git to create the reversion changeset, but not commit it, by using the @-n@ switch.

[Demo:
 * Make changes to two files, README and some other file 'foo' and commit them.
 * Now create the reversion change but don't commit it
 * @git revert -n HEAD@ 
 * Show @git status@
]

Since we only want to revert the one file, we'll unstage all the changes.

@git unstage@ 

And now we'll stage just the file we're interested in.

@git add README; get ci -m "Reverting change to README"@

Now we'll just throw away the rest of the changes, which we don't care about:

@git reset --hard@




















<!-- ADVANCED STUFF, SAVE FOR END OF SCREENCAST, NOT DONE-->


h3. ADVANCED: Changing commit history to clean up change sets

*WARNING:* you should never alter commit history after you have pushed your changes to a remote repository.

If you've been following the above techniques and keeping your work in separate branches, squashing full changesets into master, you'll hopefully never have to do interactive rebasing. However, one scenario where this technique is useful is when you've pulled a large set of changes from another repo (more on working with others later in the screencast). 

Your friend may not have been following the clean changeset philosophy as you have, so you'd like to fix the commits you just pulled from him by fixing some commit messages, maybe edit some of the code in one of the commits, and perhaps combining some of his commits into larger changesets.

The @rebase -i@ command is a powerful way to gain editorial capabilities over your last N commits. To launch it, use the following syntax:

@git rebase -i [commit to start with]@

The main argument to this command can either be a specific commit hash, or you can use the special HEAD^ for the previous commit, or HEAD~N syntax to refer to the HEAD at N commits ago.

Once you have done this, you'll be presented with an editor screen with instructions. It will look something like this:

[Demo:
  Before this demo starts, make sure you've made at least four commits to the README or some other file in the demo source tree so that there is something to rebase. We'll also be doing the work on a temporary branch so as not to mess up our master. Let's first create the temp branch.
  
  git nb temp master
  
  Launch the rebase for the last 3 commits with 
  
  git rebase -i HEAD~3

 Show the output, which looks something like this:
<pre>
  pick 06e0e1a some change
  pick 850150f another change
  pick 737b01b foo bar baz

  # Rebase 5926a38..737b01b onto 5926a38
  #
  # Commands:
  #  pick = use commit
  #  edit = use commit, but stop for amending
  #  squash = use commit, but meld into previous commit
  #
  # If you remove a line here THAT COMMIT WILL BE LOST.
</pre>
]

Something to note is that the commits are actually presented in chronological order, with the latest commit on the bottom. This is counter to most of git's displays of commits (for example, the 'git log' command displays the most recent commit on top).

The screen offers a clean set of instructions to follow. The interactive rebase enables you to do three basic things: delete commits, edit commits, and squash several commits together into one. The most common and straighforward usecase is to squash commits. We do not recommend using the edit feature, as it is confusing and easy to make a mistake, however for those who are interested, interactive rebase editing will be covered at the end of the screencast.

As before, if you decide you've made a mistake and want to abandon your rebasing, simply use @git rebase --abort@. Another way to stop a rebase is when you're looking at the rebase editing screen, delete everything on it and exit.

We'll start by looking at our current commit history. 

[Demo:
  For this demo, first make four changes to the README file, something simple like adding a line each time and commit in four different commits.

  @git short@

  Show the output:
  
  017df6c 52 seconds ago yan Change four
  0ece00d 87 seconds ago yan Change three
  2c870e2 2 minutes ago yan Change two
  7de7832 2 minutes ago yan First change
]

The @short@ command is an alias for a nicely formatted set of changes that's a little easier to read than git's default log output. Let's say we now want to squash changes two and three into one, since they're actually work on the same bug.

[Demo:

  git rebase -i HEAD~3

  You are presented with a screen like this:
  
  pick 2c870e2 Change two
  pick 0ece00d Change three
  pick 017df6c Change four

  Now we'll squash change three into change two:
  
  pick 2c870e2 Change two
  squash 0ece00d Change three
  pick 017df6c Change four

  Save and exit the screen. We are now presented with a commit screen for the newly squashed changes. We will make the commit message "Change two and Change three". Save and quit the editor. Show output:
  
  [detached HEAD]: created 02521cf: "Change two and Change three"
   1 files changed, 2 insertions(+), 0 deletions(-)
  Successfully rebased and updated refs/heads/master.
  
  Now, the 'proof', show the output of 'git short' again.
  
  ac56fcb 18 seconds ago yan Change four
  02521cf 58 seconds ago yan Change two and Change three
  7de7832 12 minutes ago yan First change
  
  We can also use "git show 02521cf" to verify that the change looks like we expect it to.
]


You can learn more about interactive rebasing here: <a href="http://book.git-scm.com/4_interactive_rebasing.html">http://book.git-scm.com/4_interactive_rebasing.html</a>


h3. Editing during interactive rebase

[Demo:
 Do the interactive rebase, and change the second commit to "edit".
 TODO: FINISH THIS SECTION
]